\chapter{Регулярные языки}


Регулярные языки --- иерархии, связанные с конечные автоматы, взаимные конвертации, основные свойства регулярных языков, такие как замкнутость относительно различных операций.


\section{Регулярные выражения}

\begin{definition}
    Регулярное множество (над алфавитом $\Sigma$) это:
    \begin{itemize}
        \item $\varnothing$
        \item $\{\varepsilon\}$
        \item $\{t\}$, $t \in \Sigma$
        \item $R_1 \cup R_2$, где $R_1$ и $R_2$ --- регулярные множества
        \item $R_1 \cdot R_2$, где $R_1$ и $R_2$ --- регулярные множества
        \item $R^*$, где $R$ --- регулярное множество
    \end{itemize}
\end{definition}


\begin{definition}
    Регулярное выражение.
    \begin{itemize}
        \item $\varepsilon$
        \item $t$
        \item $R_1 \mid R_2$
        \item $R_1 \cdot R_2$
        \item $R^*$
    \end{itemize}
\end{definition}

\section{Конечные автоматы}

\begin{definition}\label{def:FiniteAutomata}
    \textit{Конечный автомат} --- это пятёрка $M = \langle Q, q_S, Q_F, \delta, \Sigma \rangle$, где
    \begin{itemize}
        \item $Q$ --- конечное множество состояний
        \item $q_S \in Q$ --- стартовое состояние
        \item $Q_F \subseteq Q$ --- множество финальных состояний
        \item $\delta \subseteq Q \times (\Sigma \cup \varepsilon) \times Q$ --- функция переходов, а $\varepsilon \notin \Sigma$
        \item $\Sigma$ --- конечный алфавит
    \end{itemize}
\end{definition}

Заметим, что определение~\ref{def:FiniteAutomata} 

В зависимости от того, как именно представлена функция переходов: список троек, матрица, граф.

\begin{example}
    Пример КА.    
    \begin{tikzpicture}
        
    \end{tikzpicture}
\end{example}


\begin{definition}
    Конфигурация, переход между конфигурациями.
\end{definition}

\begin{example}
Пример интерпретации конечного автомата.
\end{example}

Построение КА по регулярному выражению и регулярному выражению по КА. На производных.

Алгоритмы: проверка пустоты ... 

Примеры.


\section{Лево(право)линейные грамматики}

Наложив некоторые ограничения на внешний вид правил грамматики можно получить грамматики, задающие регулярные языки.

\begin{definition}
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется леволиненйной, если все её правила имеют вид $$N_i \to \alpha w $$, где $N_i \in N, \alpha \in \{\varepsilon\} \cup N, w \in \Sigma ^*$.
\end{definition}

\begin{definition}
    Грамматика $G=\langle \Sigma, N, P, S \rangle$ называется праволиненйной, если все её правила имеют вид $$N_i \to  w \alpha$$, где $N_i \in N, \alpha \in \{\varepsilon\} \cup N, w \in \Sigma ^*$.
\end{definition}



Ноам Хомский и Джордж Миллер в работе~\cite{chomsky1958finite} показали, что лево(право)линейные грамматики задают регулярные языки. 
Приведём процедуры построения автомата по грамматике и наоборот, грамматики по автомату.

Пусть дан конечный автомат $M = \langle \Sigma, Q, q_s, Q_f, \delta \rangle$. По нему можно построить праволинейную грамматику $G=\langle \Sigma, N, S, P \rangle$, где
\begin{itemize}
    \item $N = Q$
    \item $P = \{ q_i \to t q_j \mid (q_i, t, q_j)\in \delta\} \cup \{ q_i \to \varepsilon \mid q_i \in Q_F\}$
    \item $S = q_s$
\end{itemize}

Аналогичным образом строится автомат по праволинейной грамматике.
Упростить процедуру можно если заранее привести правила к виду $N_i \to tN_j$, где $t\in \Sigma$, добавив необходимое количество новых нетерминалов:
правило вида $N_i \to twN_k$ преобразуется в два правила 
\begin{align*}
    N_i& \to tN_l\\
    N_l& \to wN_k \\
\end{align*}
, после чего аналогично преобразуется правило для $N_l$.

Пример построения грамматики по автомату.

Автомат по грамматике. 

\section{Лемма о накачке}

Лемма о накачке для регулярных языков позволяет проверить, что заданный язык не является регулярным.

\begin{lemma}
    Пусть $L$ --- регулярный язык над алфавитом $\Sigma$, тогда существует такое $n$, что для любого слова $\omega \in L$, $|\omega| \geq n$ найдутся слова $x,y,z\in \Sigma^*$, для которых верно: $xyz = \omega, y\neq \varepsilon,|xy|\leq n$ и для любого $k \geq 0$  $xy^kz \in L$.
\end{lemma}

Идея доказательства леммы о накачке.

\begin{enumerate}
    \item Так как язык регулярный, то для него можно построить конечный автомат $M = \langle Q, q_s,Q_f, \delta, \Sigma \rangle$. В том числе, минимальный по количеству состояний.
    \item В качестве $n$ возьмём $|Q| + 1$.
    \item Легко заметить, что для любой цепочки $w \in L, |w| > n$ путь в автомате, соответствующий принятию данной цепочки, будет содержать хотя бы один цикл.
          Действительно, в ориентированном графе с $k$ вершинами (а именно таким является автомат по построению) максимальная длина пути без повторных посещений вершин (соответственно, без циклов) не больше $k - 1$.
    \item Выберем любой цикл. Он будет задавать искомые цепочки $x, y$ и $z$ так, как представлено на рисунке~\ref{fig:reg_lang_pumping_lemma}.
    Заметим, что вход в цикл и выход из него в общем случае могут не совпадать, что даёт несколько вариантов разбиения пути на части, и на рисунке представлен лишь один из возможных.
\end{enumerate}

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[state, initial] (q1) {$q_1$};
            \node[state, right of=q1] (q2) {$q_2$};
            \node[state, accepting, right of=q2] (q3) {$q_3$};
            \node[state, above of=q2] (q4) {$q_4$};
            \draw (q1) edge[above, snake it] node{} (q2)
            (q2) edge[bend right, snake it, side by side={red}{blue}] node{} (q4)
            (q4) edge[bend right, snake it, color=blue] node[left]{$y$} (q2)
            (q4) edge[above, snake it, color=green] node[right]{$z$} (q3)
            (q1) edge[above, snake it, color=red] node{$x$} (q2)
            ;
        \end{tikzpicture}
    \end{center}
    \caption{Иллюстрация идеи доказательства леммы о накачке для регулярных языков: любой путь в графе, длина которого достаточно большая, может быть разбит на три части из леммы ($x$--- красный подпуть, $y$ --- синий, $z$ --- зелёный), а многократный проход по циклу $y$ позволяет ``накачать'' слово}
    \label{fig:reg_lang_pumping_lemma}
\end{figure}


\section{Замкнутость регулярных языков относительно операций}

\begin{theorem}
    Регулярные языки замкнуты относительно перечисленных ниже операций.
    \begin{enumerate}
        \item Пересечение
        \item Дополнение
        \item Обращение
        \item Разность
    \end{enumerate}
\end{theorem}

Линейная алгебра для работы с регулярными языками: пересечение, замыкание.

Построение пересечения через тензорное произведение автоматов.

Пересечение через синхронный обход в ширину.

%\section{Вопросы и задачи}
%
%Построить базу.
%
%Научиться выполнять запросы через линейку. 