\chapter{Некоторые сведения из теории графов}\label{chpt:GraphTheoryIntro}

В данном разделе мы дадим определения базовым понятиям из теории графов, рассмотрим несколько классических задач из области анализа графов и алгоритмы их решения. Кроме этого, поговорим о связи между линейной алгеброй и некоторыми задачами анализа графов.
Всё это понадобится нам при последующей работе.

\section{Основные определения}

\begin{definition}
  \textit{Помеченный ориентированный граф} $\mathcal{G} = \langle V, E, L \rangle$, где $V$ --- конечное множество вершин, $E$ --- конечное множество рёбер, т.ч. $E \subseteq V \times L \times V$, $L$ --- конечное множество меток на рёбрах. В некоторых случаях метки называют \textit{весами}\footnote{Весами метки называют ,как правило, тогда, когда они берутся из какого-либо поля, например $\mathbb{R}$ или $\mathbb{N}$.} и тогда говорят о \textit{взвешенном} графе.
\end{definition}


\begin{definition}
  В случае, если для любого ребра $(u,l,v)$ в графе также содержится ребро $(v,l,u)$, говорят, что граф \textit{неориентированный}.
\end{definition}


В дальнейшем речь будет идти о конечных ориентированных помеченных графах.
Мы будем использовать термин \textit{граф} подразумевая именно конечный ориентированный помеченный граф, если только не оговорено противное.

Также мы будем считать, что все вершины занумерованы подряд с нуля.
То есть можно считать, что $V$ --- это отрезок $[0, |V| - 1]$ неотрицательных целых чисел, где $|V|$ --- мощность множества $V$.

\begin{example}[Пример графа и его графического представления]
  Пусть дан граф 
  \begin{align*}
    \mathcal{G} = \langle V&=\{0,1,2,3\},\\
                            E&=\{(0,a,1), (1,a,2), (2,a,0), (2,b,3), (3,b,2)\}, \\
                            L&=\{a,b\} \rangle.
  \end{align*}

  Графическое представление графа $\mathcal{G}$:
  \begin{center}
  \input{figures/graph/graph0}
  \end{center}
\end{example}

\begin{example}[Пример рёбер графа]
$(0,a,1)$  и $(3,b,2)$ --- это рёбра графа $\mathcal{G}_1$. При этом, $(3,b,2)$ $(2,b,3)$ --- это разные рёбра.
\end{example}

\begin{definition}
  \textit{Путём} $\pi$ в графе $\mathcal{G}$ будем называть последовательность рёбер такую, что для любых двух последовательных рёбер $e_1=(u_1,l_1,v_1)$ и $e_2=(u_2,l_2,v_2)$ в этой последовательности, конечная вершина первого ребра является начальной вершиной второго, то есть $v_1 = u_2$. Будем обозначать путь из вершины $v_0$ в вершину $v_n$ как $v_0 \pi v_n$. Иными совами, $$v_0 \pi v_n = e_0,e_1, \dots, e_{n-1} = (v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_{n-1},v_n).$$

  Часто для представления пути мы буем использовать следующие нотации:
\begin{center}
  \input{figures/graph/path0.tex}
\end{center}
\end{definition}
 или  
$$
v_0 \xrightarrow[]{l_0} v_1 \xrightarrow[]{l_1} v_2 \xrightarrow[]{l_2} \ldots \xrightarrow[]{l_{n-2}} v_{n-1} \xrightarrow[]{l_{n-1}} v_n.
$$

\begin{example}[Пример путей графа]
$(0,a,1),(1,a,2) = 0\pi_1 2$  --- путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$.
При этом, $(0,a,1),(1,a,2),(2,b,3),(3,b,2) = 0\pi_2 2$ --- это тоже путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$, но он не равен $0\pi_1 2$.
\end{example}

Кроме того, нам потребуется отношение, отражающее факт существования пути между двумя вершинами.

\begin{definition}\label{def:reach}
  \textit{Отношение достижимости} в графе:
  $(v_i,v_j) \in P \iff \exists v_i \pi v_j$.
\end{definition}

Отметим, что в некоторых задачах удобно считать по-умолчанию, что $(v_i,v_i) \in P$, однако наше определение такого не допускает. Исправить ситуацию можно явно добавив петли $(v_i,l,v_i)$ для всех вершин.

Один из способов задать граф --- это задать его \textit{матрицу смежности}.

\begin{definition}
  \textit{Матрица смежности} графа $\mathcal{G}=\langle V,E,L \rangle$ --- это квадратная матрица $M$ размера $n \times n$, где $|V| = n$, построенная над коммутативным моноидом $\mathbb{G} = (S,\circ\colon S \times S \to S)$, который конструируется следующим образом.

  \begin{enumerate}
    \item $L \subseteq S$.
    \item $\circ$ --- коммутативная бинарная операция.
    \item Существует $ \mathbb{0} \in (S \setminus L)$ --- нейтральный элемент относительно $\circ$.    
  \end{enumerate}

  При этом $M[i,j] = \bigcirc_{(i,l,j) \in E}l$, где $\bigcirc_\varnothing = \mathbb{0}$.
\end{definition}

Заметим, что наше определение матрицы смежности отличается от классического, в котором матрица является булевой и отражает лишь факт наличия хотя бы одного ребра. То есть $M[i,j] = 1 \iff \exists e = (i,\_,j) \in E$.

\begin{example}[Пример матрицы смежности неориентированного графа]\label{exmpl:undirectedGraphMatrix}
  Пусть дан следующий неориентированный граф.
  \begin{center}
    \input{figures/graph/graph1.tex}
  \end{center}

$\mathbb{G} = (S,\circ)$ в этом случае конструируется следующим образом. Во-первых, придётся предположить, что $L$ --- множество с одним элементом, скажем $s$, и считать, что все рёбра помечены им\footnote{А раз все рёбра имеют одинаковый заранее известный вес, то можно его и не писать для каждого ребра при задании графа. Поэтому привычное нам изображение получается достаточно логичным.}. Далее, $S = L \cup{\{n\}} = \{s,n\}$, где $n$ --- нейтральный элемент относительно $\circ$. Тогда $\circ$ можно определить поточечно следующим образом.
\begin{itemize}
  \item $s \circ s = s$
  \item $s \circ n = n \circ s = s$
  \item $n \circ n = n$
\end{itemize} 

Таким образом, матрица смежности данного графа выглядит следующим образом:
$$
\begin{pmatrix}
  n & s & s & n \\
  s & n & s & n \\
  s & s & n & s \\
  n & n & s & n
\end{pmatrix}
$$
, что может показаться несколько непривычным. Однако заметим, что построенная нами структура $\mathbb{G} = (\{s,n\}, \circ)$ изоморфна $\mathbb{G}' = (\{1,0\}, \vee)$. При переходе к $\mathbb{G}'$ мы получим привычную нам булеву матрицу смежности: 
  $$
  \begin{pmatrix}
    0 & 1 & 1 & 0 \\
    1 & 0 & 1 & 0 \\
    1 & 1 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix}
  $$
  Заметим, что матрица смежности неориентированного графа всегда симметрична относительно главной диагонали.
\end{example}

\begin{example}[Пример матрицы смежности ориентированного графа]\label{example:diGraph}
  Дан ориентированный граф:
  \begin{center}
  \input{figures/graph/graph2.tex}
  \end{center}

  Построить его булеву матрицу смежности можно применив рассуждения из предыдущего примера (\ref{exmpl:undirectedGraphMatrix}) и выглядеть она будет следующим образом:
  $$
  \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    1 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix}
  $$
\end{example}

\begin{example}[Пример матрицы смежности помеченного графа]
  Пусть дан следующий помеченный граф.
  \begin{center}
    \input{figures/graph/graph3.tex}
  \end{center}

  В данном случае $L = \{\{a\},\{b\}\}$, а $\mathbb{G} = ( \{\{a\},\{b\},\{a,b\},\varnothing\} ,\cup)$, где $\varnothing$ --- нейтральный элемент.
  Тогда матрица матрица смежности исходного графа выглядит следующим образом:
  $$
  \begin{pmatrix}
    \varnothing   & \{a\}       & \varnothing & \varnothing \\
    \varnothing   & \varnothing & \{a\}       & \varnothing \\
    \{a\}         & \varnothing & \varnothing & \{a,b\} \\
    \varnothing   & \varnothing & \{b\}       & \varnothing
  \end{pmatrix}
  $$
\end{example}

Необходимо заметить, что свойства $\mathbb{G}$, а значит и детали её построения, зависят от задачи, в рамках которой рассматривается граф. В примерах выше мы строили $\mathbb{G}$ из некоторых общих соображений, не специфицируя решаемую задачу, стараясь получить ожидаемый результат. Далее мы рассмотрим пример, в котором видно, как решаемая задача влияет на построение $\mathbb{G}$.

\begin{example}[Пример матрицы смежности взвешенного графа]\label{example:apspGraph}
  Пусть дан следующий взвешенный граф:
  \begin{center}
    \input{figures/graph/graph4.tex}
  \end{center}

  Будем считать, что веса берутся из $\mathbb{R}$, а решаемая задача --- поиск кратчайших путей между вершинами. В таком случае естественно предположить, что для любой вершины $v_i$ существует петля $(v_i,0,v_i)$, хоть она явно и не изображена. Далее, $\mathbb{G} = ( \mathbb{R}\cup \{\infty\} , \min)$, где $\infty$ --- нейтральный элемент относительно операции $\min$. 

  В результате мы получим следующую матрицу смежности:
  $$
  \begin{pmatrix}
    0 & -1.4 & \infty & \infty \\
    \infty & 0 & 2.2 & \infty \\
    0.5 & \infty & 0 & 1.85 \\
    \infty & \infty & -0.76 & 0
  \end{pmatrix}
  $$
\end{example}

Таким образом, уже можно заметить, что введение моноида как абстракции позволяет достаточно унифицированным образом смотреть на различные графы и их матрицы смежности. Далее мы увидим, что данный путь позволит решать унифицированным образом достаточно широкий круг задач, связанных с анализом путей в графах. Но сперва мы сформулируем различные варианты задачи поиска путей в графе. Это необходимо для формулировки задач, на решение которых мы в конечном итоге нацелены. 


\section{Задачи поиска путей}

Одна из классических задач анализа графов --- это задача поиска путей между вершинами с различными ограничениями.

При этом, возможны различные постановки задачи.
С одной стороны, постановки различаются тем, что именно мы хотим получить в качестве результата. Здесь наиболее частыми являются следующие варианты.

\begin{itemize}
\item Наличие хотя бы одного пути, удовлетворяющего ограничениям, в графе. В данном случае не важно, между какими вершинами существует путь, важно лишь наличие его в графе.

\item Наличие пути, удовлетворяющего ограничениям, между некоторыми вершинами: задача достижимости.
      При данной постановке задачи, нас интересует ответ на вопрос достижимости вершины $v_i$ из вершины $v_j$ по пути, удовлетворяющему ограничениям.
      Такая постановка требует лишь проверить существование пути, но не его предоставления в явном виде.

\item Поиск одного пути, удовлетворяющего ограничениям: необходимо не только установить факт наличия пути, но и  предъявить его. При этом часто подразумевается, что возвращается любой путь, являющийся решением, без каких-либо дополнительных ограничений. Хотя, например, в некоторых задачах дополнительное требование простоты или наименьшей длинны выглядит достаточно естественным.

\item Поиск всех путей: необходимо предоставить все пути, удовлетворяющие заданным ограничениям.
\end{itemize}

С другой стороны, задачи могут различаться ещё и тем, как фиксируются множества стартовых и конечных вершин.
Здесь возможны следующие варианты:
\begin{itemize}
\item от одной вершины до всех,
\item между всеми парами вершин,
\item межу фиксированной парой вершин,
\item между двумя множествами вершин $V_1$ и $V_2$, что подразумевает решение задачи для всех $(v_i,v_j) \in V_1 \times V_2$.
\end{itemize}

Стоит отметить, что последний вариант является самым общим и остальные --- лишь его частные случаи. 
Однако этот вариант часто выделяют отдельно, подразумевая, что остальные, выделенные, варианты в него не включаются.

В итоге, перебирая возможные варианты желаемого результата и способы фиксации стартовых и финальных вершин, мы можем сформулировать достаточно большое количество задач. Например, задачу поиска всех путей между двумя заданными вершинами, задачу поиска одного пути от фиксированной стартовой вершины до каждой вершины в графе, или задачу достижимости между всеми парами вершин.

Часто поиск путей сопровождается изучением их свойств, что далее приводит к формулированию дополнительных ограничений на пути в терминах этих свойств. Например, можно потребовать, чтобы пути были простыми или не проходили через определённые вершины. Один из естественных способов описывать свойства и, как следствие, задавать ограничения --- это использовать ту алгебраическую структуру, из которой берутся веса рёбер графа\footnote{На самом деле здесь наблюдается некоторая двойственность. С одной стороны, действительно, удобно считать, что свойства описываются в терминах некоторой заданной алгебраической структуры. Но, вместе с этим, структура подбирается исходя из решаемой задачи.}. 

Предположим, что дан граф $\mathcal{G} = \langle V, E, L\rangle $, где $L = \langle S, \oplus, \otimes \rangle$ --- это полукольцо. Тогда изучение свойств путей можно описать следующим образом: 
\begin{equation} \label{eq:algPathProblem} 
  \{(v_i, v_j, c) \mid \exists v_i \pi v_j, c = \bigoplus_{\forall v_i \pi v_j} \bigotimes_{(u,l,v) \in \pi } l \}.
\end{equation}

Иными словами, для каждой пары вершин, для которой существует хотя бы один путь, их соединяющий, мы агрегируем (с помощью операции $\oplus$ из полукольца) информацию обо всех путях между этими вершинами. При этом информация о пути получается как свёртка меток рёбер пути с использованием операции $\otimes$\footnote{Заметим, что детали свёртки вдоль пути зависят от свойств полукольца (и от решаемой задачи). Так, если полукольцо коммутативно, то нам не обязательно соблюдать порядок рёбер. В дальнейшем мы увидим, что данные особенности полукольца существенно влияют на особенности алгоритмов решения соответствующих задач.}.

Естественным требованием (хотя бы для прикладных задач, решаемых таким способом) является существование и конечность указанной суммы. На данном этапе мы не будем касаться того, какие именно свойства полукольца могут нам обеспечить данное свойство, однако в дальнейшем будем считать, что оно выполняется. Более того, будем стараться приводить частные для конкретной задачи рассуждения, показывающие, почему это свойство выполняется в рассматриваемых в задаче ограничениях.

Описанная выше задача общего вида называется анализом свойств путей алгебраическими методами (Algebraic Path Problem~\cite{Baras2010PathPI}) и предоставляет общий способ для решения широкого класса прикладных задач\footnote{В работе ``Path Problems in Networks''~\cite{Baras2010PathPI}, упомянутой чуть выше, собран действительно большой список прикладных задач с описанием соответствующих полуколец. Сводная таблица на страницах 58--59 содержит 29 различных прикладных задач и соответствующих полуколец.}. Наиболее известными являются такие задачи, как построение транзитивного замыкания графа и поиск кратчайших путей. Далее мы подробнее обсудим эти две задачи и предложим алгоритмы их решения.


\section{Алгоритм Флойда-Уоршелла}

Наиболее естественным образом решение обсуждаемых выражается в терминах операций над матрицей смежности исходного графа. Поэтому предположим, что исходный граф задан матрицей над моноидом $\mathbb{G} = (S,\oplus)$.

Как мы видели ранее, операция $\oplus$ позволяет нам агрегировать информацию по всем параллельным рёбрам. Ровно она же и будет агрегировать информацию по всем путям между двумя вершинами\footnote{Вообще говоря, работая с матрицей смежности мы не видим разницу между путём и ребром, так как любая запись в матрице смежности в ячейке $[i,j]$ говорит нам только о том, что вершины $i$ и $j$ связаны и эта связь обладает некоторым свойством (значение в ячейке), и ничего не говорит о том, как эта связь устроена.}. Таким образом, осталось сконструировать операцию, отвечающую за агрегацию информации вдоль пути. Здесь мы будем исходить из того, что новый путь может быть получен из двух подпутей, а свойство нового пути зависит только от свойств исходных подпутей.

Таким образом, дополнительная операция, обозначим её $\otimes: S \times S \to S$\footnote{При первом рассмотрении такой выбор кажется контринтуитивным. Действительно, ведь при соединении путей мы как бы ``складываем'' их веса. Но при более детальном анализе поведения этой операции, в частности, относительно нейтрального элемента, становится понятно, что она ведёт себя очень похоже на умножение. Вероятно, стоит обратить внимание на операцию конкатенации, которая, с одной стороны, ``делает то, что нам нужно'', а с другой, (и неспроста) часто обозначается $\cdot$.}, должна вести себя следующим образом. Пусть $S$ --- носитель моноида, $\mathbb{0} \in S$ --- нейтральный элемент относительно $\oplus$.  
\begin{itemize}
  \item $s_1 \otimes s_2 = s_3, s \in S, s \neq \mathbb{0}$ : если существует путь $i \pi j$ со свойством $s_1$ и путь $j \pi k$ со свойством $s_2$, то существует путь $i \pi k$ со свойством $s_3$.
  \item $s \otimes \mathbb{0} = \mathbb{0}$ : если существует путь $i \pi j$ со свойством $s$ и не существует пути $j \pi k$, то не существует и пути $i \pi k$.
  \item $\mathbb{0} \otimes s = \mathbb{0}$ : если не существует пути $i \pi j$ и существует путь $j \pi k$ со свойством $s$, то не существует и пути $i \pi k$.
  \item $\mathbb{0} \otimes \mathbb{0} = \mathbb{0}$ : если не существует пути $i \pi j$ и не существует пути $j \pi k$, то не существует и пути $i \pi k$.
\end{itemize}

Новую операцию добавим к моноиду и получим новую алгебраическую структуру $\mathbb{G}' = (S, \oplus,\otimes)$. Данная структура является коммутативным моноидом по сложению (по построению) с нейтральным элементом $\mathbb{0}$. Из построения $\otimes$ видно, что $\mathbb{0}$ является аннигилятором. Ничего более про операцию $otimes$, а значит и про $\mathbb{G}'$ мы сказать, исходя из построения, не можем. Классический фреймворк для решения algebraic path problem подразумевает, что $\mathbb{G}'$ является полукольцом, однако далее мы увидим, что существуют задачи, в которых $otimes$, например, не является ассоциативной\footnote{Такой будет рассматриваемая в данной работе задача достижимости с ограничениями в терминах формальных языков. Другие примеры можно найти в уже упоминавшейся работе~\cite{Baras2010PathPI}}. А значит, согласно нашему определению, $\mathbb{G}'$ полукольцом не является. 

Теперь, когда построена алгебраическая структура, обеспечивающая вычисление формулы~
\ref{eq:algPathProblem}, мы можем предложить алгоритм вычисления этой формулы и данным алгоритмом в интересующих нас частных случаях будет являться алгоритм Флойда-Уоршелла~\cite{Floyd1962, Bernard1959, Warshall1962}. Псевдокод алгоритма в обобщённом виде представлен на листинге~\ref{lst:algoFloydWarxhall}. Он практически дословно основан на описанной выше идее сборки путей из двух подпутей: тройной вложенный цикл перебирает все возможные разбиения пути на две части, а в строке 7 как раз и происходит вычисление формулы~
\ref{eq:algPathProblem}.  

Необходимо обратить внимание на несколько вещей. Первая --- порядок обхода. Внешний цикл перебирает возможные точки разбиения (хотя мог бы, например, перебирать начальные вершины) для того, чтобы гарантировать правильный порядок вычисления подпутей (информация ни о каких подпутях не будет получена после того, как они поучаствовали в построении более длинного пути). Вторая --- количество итераций. В данном случае мы ограничились тройным вложенным циклом от 0 до $n$ и для наших задач этого будет достаточно, однако, как доказательство этого факта, так и построение аналогичного алгоритма для других задач требует аккуратного анализа решаемой задачи и последующего доказательства корректности построенного алгоритма.

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Алгоритм Флойда-Уоршелла}
\label{lst:algoFloydWarxhall}
\Function{FloydWarshall}{$\mathcal{G}$}
    \State{$M \gets$ матрица смежности $\mathcal{G}$} 
    \Comment{Матрица над $\mathbb{G}=(S,\oplus,\otimes)$}
    \State{$n \gets |V(\mathcal{G})|$}
    \For{k = 0; k < n; k++} 
      \For{i = 0; i < n; i++}
        \For{j = 0; j < n; j++}
          \State{$M[i,j] \gets M[i,j] \oplus (M[i,k] \otimes M[k,j])$}
        \EndFor
      \EndFor
    \EndFor
\State \Return $M$
\EndFunction
\end{algorithmic}
\end{algorithm}

Хотя изначально данный алгоритм был предложен для решения задачи о кратчайших путях, при абстрагировании алгебраической структуры он превращается в алгоритм решения целого ряда задач. В частности --- нахождения транзитивного замыкания. Так, если возьмём тропическое полукольцо $(\mathbb{R}_{+\infty}, \min, +)$, то получим алгоритм для поиска кратчайших путей. Если же возьмём булево полукольцо, то получим алгоритм для построения транзитивного замыкания графа.

\begin{example}[Транзитивное замыкание графа]
  Пусть дан следующий граф:
  \begin{center}
    \input{figures/graph/graph2.tex}
  \end{center}

  Его матрица смежности:
  $$ M = 
  \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    1 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix}
  $$

  Здесь мы считаем, что отношение достижимости не рефлексивно: все диагональные элементы матрицы $M$ равны 0. 

  Воспользовавшись алгоритмом из листинга~\ref{lst:algoFloydWarxhall}, специализированного на случай булева полукольца, можно получить следующую матрицу смежности.

  $$ M' = 
  \begin{pmatrix}
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1
  \end{pmatrix}
  $$

  А значит, транзитивным замыканием исходного графа является полный граф и он выглядит следующим образом.
  
  \begin{center}
    \input{figures/graph/graph5.tex}
  \end{center}

\end{example}

Заметим, что рефлексивность отношения (значения элементов на главной диагонали матрицы смежности) непосредственно связана с особенностями решаемой задачи. Например, если говорить о кратчайших расстояниях, то кажется естественным считать расстояние от вершины до самой себя равной нулю. Однако для задачи транзитивного замыкания это уже не столь естественное предположение и часто отдельно говорят от рефлексивно-транзитивном замыкании, которое отдельно явным образом привносит рефлексивность (петли, диагональные элементы матрицы смежности).

Аналогичным образом, используя данный алгоритм, но уже для тропического полукольца, можно решить задачу о поиске кратчайших путей для графа из примера~\ref{example:apspGraph}.

Идеи, заложенные в алгоритме Флойда-Уоршелла, а также возможность абстрагировать его, помогут нам в дальнейшем предложить алгоритм для задачи достижимости с ограничениями в терминах формальных языков.

\section{Графы и линейная алгебра}

В данной главе мы рассмотрим некоторые связи\footnote{Связь между графами и линейной алгеброй --- обширная область, в которой можно даже выделить отдельные направления, такие как спектральная теория графов. С точки зрения практики данная связь также подмечена давно и более полно с ней можно ознакомиться, например, в работах~\cite{doi:10.1137/1.9780898719918, Davis2018Algorithm9S}. Кроме этого, много полезной информации можно найти на сайте \url{https://graphblas.github.io/GraphBLAS-Pointers/}.} между графами и операциями над ними и матрицами и операциями над матрицами. 

Как мы видели, достаточно естественное представление графа --- это его матрица смежности. 


\section{APSP и произведение матриц}

Алгоритм Флойда-Уоршелла можно переформулировать в терминах перемножения матриц над тропическим полукольцом.

Пусть $D_k$ --- матрица кратчайших путей, состоящих не более чем из $k$ рёбер. То есть $D_k[i,j]$ --- это длина кратчайшего пути из вершины $i$ в вершину $j$, такого, что он состоит не более чем из $k$ ребер. Если такого пути нет, то $D_k[i,j] = \infty$.

Таким образом, $D_1 = M$, где $M$ --- это матрица смежности исходного графа, а решением APSP является $D_{n-1}$.

\begin{center}
    $D(1) = M$ \\
    $D(2) = D(1) \cdot M = M^2$ \\
    $D(3) = D(2) \cdot M = M^3$ \\
    $\dots$ \\
    $D(n-1) = D(n-2) \cdot M = M^{n-1}$ \\
\end{center}

Итак, мы можем решить APSP за $O(n K(n))$, где $K(n)$ --- сложность алгоритма умножения матриц.

Сразу заметим, что, например, $D_3$ считать не обязательно, т.к. можем посчитать $D_4$ как $D_2 \cdot D_2$.
Поэтому:

\begin{center}
    $D_1 = M$ \\
    $D_2 = M^2 = M \cdot M$ \\
    $D_4 = M^4 = M^2 \cdot M^2$ \\
    $D_8 = M^8 = M^4 \cdot M^4$ \\
    $\dots$ \\
    $D_{2^{\log(n-1)}} = M^{2^{\log(n-1)}} = M^{2^{\log(n-1)} - 1} \cdot M^{2^{\log(n-1)} - 1}$ \\
    $D_{n-1} = D_{2^{\log(n-1)}}$ \\
\end{center}

Теперь вместо $n$ итераций нам нужно $\log{n}$. В итоге, сложность --- $O(\log{n} K(n))$.
Данный алгоритм называется \textit{repeated squaring}\footnote{Пример решения APSP с помощью repeated squaring: \url{http://users.cecs.anu.edu.au/~Alistair.Rendell/Teaching/apac_comp3600/module4/all_pairs_shortest_paths.xhtml}}.


Таким образом, APSP сводится к умножению матриц над полукольцом, что, к сожалению, не позволяет этим путём получить истинно субкубический алгоритм для задачи. тем не менее, позволяет получить слегка субкубический. Приведем некоторые работы по APSP для ориентированных графов с вещественными весами (здесь $n$ --- количество вершин в графе):
\begin{itemize}
    \item M.L. Fredman (1976) --- $O(n^3(\log \log n / \log n)^\frac{1}{3})$ --- использование дерева решений~\cite{FredmanAPSP1976}
    \item W. Dobosiewicz (1990) --- $O(n^3 / \sqrt{\log n})$ --- использование операций на Word Random Access Machine~\cite{Dobosiewicz1990}
    \item T. Takaoka (1992) --- $O(n^3 \sqrt{\log \log n / \log n})$ --- использование таблицы поиска~\cite{Takaoka1992}
    \item Y. Han (2004) --- $O(n^3 (\log \log n / \log n)^\frac{5}{7})$~\cite{Han2004}
    \item T. Takoaka (2004) --- $O(n^3 (\log \log n)^2 / \log n)$~\cite{Takaoka2004}
    \item T. Takoaka (2005) --- $O(n^3 \log \log n / \log n)$~\cite{Takaoka2005}
    \item U. Zwick (2004) --- $O(n^3 \sqrt{\log \log n} / \log n)$~\cite{Zwick2004}
    \item T.M. Chan (2006) --- $O(n^3 / \log n)$ --- многомерный принцип ``разделяй и властвуй''~\cite{Chan2008}
    \item и др.
\end{itemize}

Таким образом, вопрос о субкубических алгоритмах решения APSP всё ещё открыт~\cite{Chan2010}.




%\section{Вопросы и задачи}
%\begin{enumerate}
%  \item Реализуйте абстракцию полукольца, позволяющую конструировать полукольца с произвольными операциями.
%  \item Реализуйте алгоритм произведения матриц над произвольным полукольцом. Используйте результат решения предыдущей задачи.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм построения транзитивного замыкания через произведение матриц.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм решения задачи APSP для ориентированного через произведение матриц.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу APSP для ориентированного графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу APSP для ориентированного графа.
%  \item Сравните произволительность решений предыдущих задач
%\end{enumerate}
