\chapter{Общие сведения теории графов}\label{chpt:GraphTheoryIntro}

В данном разделе мы дадим определения базовым понятиям из теории графов, рассмотрим несколько классических задач из области анализа графов и алгоритмы их решения.
Всё это понадобится нам при последующей работе.

\section{Основные определения}

\begin{definition}
  \textit{Граф} $\mathcal{G} = \langle V, E, L \rangle$, где $V$ --- конечное множество вершин, $E$ --- конечное множество рёбер, т.ч. $E \subseteq V \times L \times V$, $L$ --- конечное множество меток на рёбрах.
\end{definition}

В дальнейшем речь будет идти о конечных ориентированных помеченных графах.
Мы будем использовать термин \textit{граф} подразумевая именно конечный ориентированный помеченный граф, если только не оговорено противное.

Также мы будем считать, что все вершины занумерованы подряд с нуля.
То есть можно считать, что $V$ --- это отрезок $[0, |V| - 1]$ неотрицательных целых чисел, где $|V|$ --- размер множества $V$.

\begin{example}[Пример графа и его графического представления]
  Пусть дан граф $$\mathcal{G}_1 = \langle \{0,1,2,3\}, \{(0,a,1), (1,a,2), (2,a,0), (2,b,3), (3,b,2)\}, \{a,b\} \rangle.$$
  Графическое представление графа $\mathcal{G}_1$:
  \begin{center}
  \input{figures/graph/graph0}
  \end{center}
\end{example}

\begin{definition}
  \textit{Ребро} ориентированного помеченного графа $\mathcal{G} = \langle V, E, L \rangle$ это упорядоченная тройка $e = (v_i,l,v_j) \in V \times L \times V$.
\end{definition}

\begin{example}[Пример рёбер графа]
$(0,a,1)$  и $(3,b,2)$ --- это рёбра графа $\mathcal{G}_1$. При этом, $(3,b,2)$ $(2,b,3)$ --- это разные рёбра, что видно из рисунка.
\end{example}

\begin{definition}
  \textit{Путём} $\pi$ в графе $\mathcal{G}$ будем называть последовательность рёбер такую, что для любых двух последовательных рёбер $e_1=(u_1,l_1,v_1)$ и $e_2=(u_2,l_2,v_2)$ в этой последовательности, конечная вершина первого ребра является начальной вершиной второго, то есть $v_1 = u_2$. Будем обозначать путь из вершины $v_0$ в вершину $v_n$ как $$v_0 \pi v_n = e_0,e_1, \dots, e_{n-1} = (v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_n,v_n).$$

\begin{center}
  \input{figures/graph/path0.tex}
\end{center}
\end{definition}

\begin{example}[Пример путей графа]
$(0,a,1),(1,a,2) = 0\pi_1 2$  --- путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$.
При этом, $(0,a,1),(1,a,2),(2,b,3),(3,b,2) = 0\pi_2 2$ --- это тоже путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$, но он не равен $0\pi_1 2$.
\end{example}

Кроме того, нам потребуется отношение, отражающее факт существования пути между двумя вершинами.

\begin{definition}\label{def:reach}
  \textit{Отношение достижимости} в графе:
  $(v_i,v_j) \in P \iff \exists v_i \pi v_j$.
\end{definition}

Отметим, что рефлексивность этого отношения часто зависит от контекста.
В некоторых задачах по-умолчанию $(v_i,v_i) \notin P$, а чтобы это было верно, требуется явное наличие ребра-петли.

Один из способов задать граф --- это задать его \textit{матрицу смежности}.

\begin{definition}
  \textit{Матрица смежности} графа $\mathcal{G}=\langle V,E,L \rangle$ --- это квадратная матрица $M$ размера $n \times n$, где $|V| = n$ и ячейки которой содержат множества.
  При этом $l \in M[i,j] \iff \exists e = (i,l,j) \in E$.
\end{definition}

Заметим, что наше определение матрицы смежности отличается от классического, в котором матрица отражает лишь факт наличия хотя бы одного ребра и, соответственно, является булевой. То есть $M[i,j] = 1 \iff \exists e = (i,\_,j) \in E$.


Также можно встретить матрицы смежности, в ячейках которых всё же хранится некоторая информация, однако, в единственном экземпляре. То есть запрещены параллельные рёбра.
Такой подход часто можно встретить в задачах о кратчайших путях: в этом случае в ячейке хранится расстояние между двумя вершинами.
При этом, так как в качестве весов часто рассматривают произвольные (в том числе отрицательные) числа, то в задачах о кратчайших путях отдельно вводят значение ``бесконечность'' для обозначения ситуации, когда между двумя вершинами нет пути или его длина ещё не известна.
Всё это приводит к тому, что \textit{матрица смежности} --- это обобщённое понятие, нежели конкретный специальный тип матриц.
Данная конструкция даёт общее представление о том, как в матричном виде ханить различную информацию о смежноти вершин в графе.

\begin{example}[Пример матрицы смежности неориентированного графа]
  Неориентированный граф:
  \begin{center}
    \input{figures/graph/graph1.tex}
  \end{center}

  И его матрица смежности:
  $$
  \begin{pmatrix}
    1 & 1 & 1 & 0 \\
    1 & 1 & 1 & 0 \\
    1 & 1 & 1 & 1 \\
    0 & 0 & 1 & 1
  \end{pmatrix}
  $$
\end{example}

\begin{example}[Пример матрицы смежности ориентированного графа]
  Ориентированный граф:
  \begin{center}
  \input{figures/graph/graph2.tex}
  \end{center}

  И его матрица смежности:
  $$
  \begin{pmatrix}
    1 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 \\
    1 & 0 & 1 & 1 \\
    0 & 0 & 1 & 1
  \end{pmatrix}
  $$
\end{example}

\begin{example}[Пример матрицы смежности помеченного графа]
  Помеченный граф:
  \begin{center}
    \input{figures/graph/graph3.tex}
  \end{center}

  И его матрица смежности:
  $$
  \begin{pmatrix}
    \varnothing   & \{a\}       & \varnothing & \varnothing \\
    \varnothing   & \varnothing & \{a\}       & \varnothing \\
    \{a\}         & \varnothing & \varnothing & \{a,b\} \\
    \varnothing   & \varnothing & \{b\}       & \varnothing
  \end{pmatrix}
  $$
\end{example}

\begin{example}[Пример матрицы смежности взвешенного графа]
  Взвешенный граф для задачи о кратчайших путях:
  \begin{center}
    \input{figures/graph/graph4.tex}
  \end{center}

  И его матрица смежности (для задачи о кратчайших путях):
  $$
  \begin{pmatrix}
    0 & -1.4 & \infty & \infty \\
    \infty & 0 & 2.2 & \infty \\
    0.5 & \infty & 0 & 1.85 \\
    \infty & \infty & -0.76 & 0
  \end{pmatrix}
  $$
\end{example}

Мы ввели лишь общие понятия.
Специальные понятия, необходимые для изложения конкретного материала, будут даны в соответствующих главах.

\section{Графы и линейная алгебра}

В данной главе мы рассмотрим некоторые связи\footnote{Связь между графами и линейной алгеброй --- обширная область, в которой можно даже выделить отдельные направления, такие как спектральная теория графов. С точки зрения практики данная связь также подмечена давно и более полно с ней сожно ознакомиться, например, в работах~\cite{doi:10.1137/1.9780898719918, Davis2018Algorithm9S}. Кроме этого, много полезной информации можно найти на сайте \url{https://graphblas.github.io/GraphBLAS-Pointers/}.} между графами и операциями над ними и матрицами и операциями над матрицами. 

Матрицы --- рёбра. Операции над матрицами --- операции над рёбрами. 


Носитель структуры для матриц сложно связан с тем, откуда веса на рёбрах графа.

Про умножение. Конкатенация рёбер, выбор из нескольких возможных вариантов: как раз две операции в полукольце. Красивая картинка про то, как умножение матриц работает с рёбрами. 

Про Кронекера и произведение графов.

\section{Задачи поиска путей}

Одна из классических задач анализа графов --- это задача поиска путей между вершинами с различными ограничениями.

При этом, возможны различные постановки задачи.
С одной стороны, по тому, что именно мы хотим получить в качестве результата:
\begin{itemize}
\item Наличие хотя бы одного пути, удовлетворяющего ограничениям, в графе. В данном случае не важно, между какими вершинами существует путь, важно лишь наличие его в графе.
\item Наличие пути, удовлетворяющего ограничениям, между некоторыми вершинами: задача достижимости.
      При данной постановке задачи, нас интересует ответ на вопрос достижимости вершина $v_1$ из вершины $v_2$ по пути, удовлетворяющему ограничениям.
      Такая постановка требует лишь проверить существование пути, но не обязательно его предоставлять в явном виде.
\item Поиск одного пути, удовлетворяющего ограничениям: необходимо не только установить факт наличия пути, но и  предъявить его. При этом часто подразумевается, что возвращается любой путь, являющийся решением, без каких-либо дополнительных ограничений. Хотя, например, в некоторых задачах дополнительное требование простоты или наименьшей длинны выглядит достаточно естественным.
\item Поиск всех путей: необходимо предоставить все пути, удовлетворяющеие заданным ограничениям.
\end{itemize}

С другой стороны, задачи различаются ещё и по тому, как фиксируются множества стартовых и конечных вершин.
Здесь возможны следующие варианты:
\begin{itemize}
\item от одной вершины до всех,
\item между всеми парами вершин,
\item межу фиксированной парой вершин,
\item между двумя множествами вершин.
\end{itemize}

Стоит отметить, что последний вариант является самым общим и сотальные --- лишь его частные случаи. 
Однако этот вариант часто выделяют отдельно, подразумевая, что остальные, выделенные, варианты в него не включаются. В итоге мы можем сформулировать прямое произведение различных постановок задач о поиске путей, перебирая возможные варианты желаемого результата и фиксируя стартоыве и финальные множетсва разными способами.

Часто при поиске путей на них накладывают дополнительные ограничения. Например, можно потребовать, чтобы пути были простыми или не проходили через определённые вершины.
Ограничение, имеющее важное прикладное значение, --- минимальность длины искомого пути.
Одна из важных задач, имеющих как прикладное, так и теоретическое значение --- \textit{поиск кратчайших путей в графе между всеми парами вершин(англ. APSP --- all-pairs shortest paths)}. Рассмотрим её более подробно. Тем более, что данная задача в определённом смысле близка к задаче, которая будет основной в данной работе, и из алгоритмов для APSP можно почерпнуть идеи для алгоритмов решения задачи поиска путей с ограничениями в терминах формальных языков.


\section{APSP и транзитивное замыкание графа}

Заметим, что отношение достижимости (\ref{def:reach}) является транзитивным.
Действительно, если существует путь из $v_i$ в $v_j$ и путь из $v_j$ в $v_k$, то существует путь из $v_i$ в $v_k$.

\begin{definition}
  \textit{Транзитивным замыканием графа} называется транзитивное замыкание отношения достижимости по всему графу.
\end{definition}

Как несложно заметить, транзитивное замыкание графа --- это тоже граф.
Более того, если решить задачу поиска кратчайших путей между всеми парами вершин, то мы построим транзитивное замыкание.

Поэтому сразу рассмотрим алгоритм Флойда-Уоршелла~\cite{Floyd1962, Bernard1959, Warshall1962}, который является общим алгоритмом поиска кратчайших путей. Данный алгоритм умеет обрабатывать рёбра с отрицательными весами, чего не может, например, алгоритм Дейкстры. Его сложность: $O(n^3)$, где $n$ --- количество вершин в графе. При этом, данный алгоритм легко упростить до алгоритма построения транзитивного замыкания. Псевдокод алгоритма представлен на листинге~\ref{lst:algoFloydWarxhall}.

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Алгоритм Флойда-Уоршелла}
\label{lst:algoFloydWarxhall}
\Function{FloydWarshall}{$\mathcal{G}$}
    \State{$M \gets$ матрица смежности $\mathcal{G}$}
    \State{$n \gets$ $|V(\mathcal{G})|$}
    \For{k = 0; k < n; k++}
      \For{i = 0; i < n; i++}
        \For{j = 0; j < n; j++}
          \State{$M[i,j] \gets M[i,j] \oplus (M[i,k] \otimes M[k,j])$}
        \EndFor
      \EndFor
    \EndFor
\State \Return $M$
\EndFunction
\end{algorithmic}
\end{algorithm}

В зависимости от того, над каким полукольцом построена матрица смежности (какого рода веса на рёбрах графа) данный алгоритм может решать несколько разные задачи. Например, если возьмём трописеское полукольцо $(\mathbb{R}_{+\infty}, \min, +)$, то получим алгоритм для поимка кратчайших путей. Если же возьмём булево полукольцо, то получим алгоритм для построения транзитивного замыкания графа.

\begin{example}[Транзитивное замыкание графа]
  Пусть дан следующий граф:
  \begin{center}
    \input{figures/graph/graph2.tex}
  \end{center}

  Его матрица смежности:
  $$ M = 
  \begin{pmatrix}
    1 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 \\
    1 & 0 & 1 & 1 \\
    0 & 0 & 1 & 1
  \end{pmatrix}
  $$

  Здесь мы считаем, что отношение достижимости рефлексивно: все диагональные элементы матрицы $M$ равны 1, хотя петель у вершин нету. 

  Воспользовавшись алгоритмом из листинга~\ref{lst:algoFloydWarxhall}, специализированного на случай булева полукольца, можно получить следующую матрицу смежности.

  $$ M' = 
  \begin{pmatrix}
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1
  \end{pmatrix}
  $$

  А значит, транзитивным замыканием исходного графа является полный граф и он выглядит следующим образом.
  
  \begin{center}
    \input{figures/graph/graph5.tex}
  \end{center}

\end{example}

Заметим, что рефлексивность отношения (значения элементов на главной диагонали матрицы смежности) непосредственно связана с особенностями решаемой задачи. Например, если говорить о кратчайших расстояних, то кажется естественным считать расстояние от вершины до самой себя равной нулю. Однако для задачи транзитивного замыкания это уже не столь естественное предположение и часто отдельно говорят от рефлексивно-транзитивном замыкании, которое отдельно явным образом привносит рефлексивность (петли, диагональные элементы матрицы смежности).



\section{APSP и произведение матриц}

Алгоритм Флойда-Уоршелла можно переформулировать в терминах перемножения матриц над тропическим полукольцом.

Пусть $D_k$ --- матрица кратчайших путей, состоящих не более чем из $k$ рёбер. То есть $D_k[i,j]$ --- это длина кратчайшего пути из вершины $i$ в вершину $j$, такого, что он состоит не более чем из $k$ ребер. Если такого пути нет, то $D_k[i,j] = \infty$.

Таким образом, $D_1 = M$, где $M$ --- это матрица смежности исходного графа, а решением APSP является $D_{n-1}$.

\begin{center}
    $D(1) = M$ \\
    $D(2) = D(1) \cdot M = M^2$ \\
    $D(3) = D(2) \cdot M = M^3$ \\
    $\dots$ \\
    $D(n-1) = D(n-2) \cdot M = M^{n-1}$ \\
\end{center}

Итак, мы можем решить APSP за $O(n K(n))$, где $K(n)$ --- сложность алгоритма умножения матриц.

Сразу заметим, что, например, $D_3$ считать не обязательно, т.к. можем посчитать $D_4$ как $D_2 \cdot D_2$.
Поэтому:

\begin{center}
    $D_1 = M$ \\
    $D_2 = M^2 = M \cdot M$ \\
    $D_4 = M^4 = M^2 \cdot M^2$ \\
    $D_8 = M^8 = M^4 \cdot M^4$ \\
    $\dots$ \\
    $D_{2^{\log(n-1)}} = M^{2^{\log(n-1)}} = M^{2^{\log(n-1)} - 1} \cdot M^{2^{\log(n-1)} - 1}$ \\
    $D_{n-1} = D_{2^{\log(n-1)}}$ \\
\end{center}

Теперь вместо $n$ итераций нам нужно $\log{n}$. В итоге, сложность --- $O(\log{n} K(n))$.
Данный алгоритм называется \textit{repeated squaring}\footnote{Пример решения APSP с помощью repeated squaring: \url{http://users.cecs.anu.edu.au/~Alistair.Rendell/Teaching/apac_comp3600/module4/all_pairs_shortest_paths.xhtml}}.


Таким образом, APSP сводится к умножению матриц над полукольцом, что, к сожалению, не позволяет этим путём получить истинно субкубический алгоритм для задачи. тем неменее, позволяет получить слегка субкубический. Приведем некоторые работы по APSP для ориентированных графов с вещественными весами (здесь $n$ --- количество вершин в графе):
\begin{itemize}
    \item M.L. Fredman (1976) --- $O(n^3(\log \log n / \log n)^\frac{1}{3})$ --- использование дерева решений~\cite{FredmanAPSP1976}
    \item W. Dobosiewicz (1990) --- $O(n^3 / \sqrt{\log n})$ --- использование операций на Word Random Access Machine~\cite{Dobosiewicz1990}
    \item T. Takaoka (1992) --- $O(n^3 \sqrt{\log \log n / \log n})$ --- использование таблицы поиска~\cite{Takaoka1992}
    \item Y. Han (2004) --- $O(n^3 (\log \log n / \log n)^\frac{5}{7})$~\cite{Han2004}
    \item T. Takoaka (2004) --- $O(n^3 (\log \log n)^2 / \log n)$~\cite{Takaoka2004}
    \item T. Takoaka (2005) --- $O(n^3 \log \log n / \log n)$~\cite{Takaoka2005}
    \item U. Zwick (2004) --- $O(n^3 \sqrt{\log \log n} / \log n)$~\cite{Zwick2004}
    \item T.M. Chan (2006) --- $O(n^3 / \log n)$ --- многомерный принцип ``разделяй и властвуй''~\cite{Chan2008}
    \item и др.
\end{itemize}

Таким образом, вопрос о субкубических алгоритмах решения APSP всё ещё открыт~\cite{Chan2010}.




%\section{Вопросы и задачи}
%\begin{enumerate}
%  \item Реализуйте абстракцию полукльца, позволяющую конструировать полукольца с произвольными операциями.
%  \item Реализуйте алгоритм произведения матриц над произвольным полукольцом. Используйте результат решения предыдущей задачи.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм построения транзитивного замыкания через произведение матриц.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм решения задачи APSP для ориентированного через произведение матриц.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу APSP для ориентированного графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу APSP для ориентированного графа.
%  \item Сравните произволительность решений предыдущих задач
%\end{enumerate}
