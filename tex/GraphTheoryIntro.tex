\chapter{Некоторые сведения из теории графов}\label{chpt:GraphTheoryIntro}

В данном разделе мы дадим определения базовым понятиям из теории графов, рассмотрим несколько классических задач из области анализа графов и алгоритмы их решения. Кроме этого, поговорим о связи между линейной алгеброй и некоторыми задачами анализа графов.
Всё это понадобится нам при последующей работе.

\section{Основные определения}

\begin{definition}
  \textit{Помеченный ориентированный граф} $\mathcal{G} = \langle V, E, L \rangle$, где $V$ --- конечное множество вершин, $E$ --- конечное множество рёбер, т.ч. $E \subseteq V \times L \times V$, $L$ --- конечное множество меток на рёбрах. В некоторых случаях метки называют \textit{весами}\footnote{Весами метки называют ,как правило, тогда, когда они берутся из какого-либо поля, например $\mathbb{R}$ или $\mathbb{N}$.} и тогда говорят о \textit{взвешенном} графе.
\end{definition}


\begin{definition}
  В случае, если для любого ребра $(u,l,v)$ в графе также содержится ребро $(v,l,u)$, говорят, что граф \textit{неориентированный}.
\end{definition}


В дальнейшем речь будет идти о конечных ориентированных помеченных графах.
Мы будем использовать термин \textit{граф} подразумевая именно конечный ориентированный помеченный граф, если только не оговорено противное.

Также мы будем считать, что все вершины занумерованы подряд с нуля.
То есть можно считать, что $V$ --- это отрезок $[0, |V| - 1]$ неотрицательных целых чисел, где $|V|$ --- мощность множества $V$.

\begin{example}[Пример графа и его графического представления]
  Пусть дан граф 
  \begin{align*}
    \mathcal{G} = \langle V&=\{0,1,2,3\},\\
                            E&=\{(0,a,1), (1,a,2), (2,a,0), (2,b,3), (3,b,2)\}, \\
                            L&=\{a,b\} \rangle.
  \end{align*}

  Графическое представление графа $\mathcal{G}$:
  \begin{center}
  \input{figures/graph/graph0}
  \end{center}
\end{example}

\begin{example}[Пример рёбер графа]
$(0,a,1)$  и $(3,b,2)$ --- это рёбра графа $\mathcal{G}_1$. При этом, $(3,b,2)$ $(2,b,3)$ --- это разные рёбра.
\end{example}

\begin{definition}
  \textit{Путём} $\pi$ в графе $\mathcal{G}$ будем называть последовательность рёбер такую, что для любых двух последовательных рёбер $e_1=(u_1,l_1,v_1)$ и $e_2=(u_2,l_2,v_2)$ в этой последовательности, конечная вершина первого ребра является начальной вершиной второго, то есть $v_1 = u_2$. Будем обозначать путь из вершины $v_0$ в вершину $v_n$ как $v_0 \pi v_n$. Иными совами, $$v_0 \pi v_n = e_0,e_1, \dots, e_{n-1} = (v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_{n-1},v_n).$$

  Часто для представления пути мы буем использовать следующие нотации:
\begin{center}
  \input{figures/graph/path0.tex}
\end{center}
\end{definition}
 или  
$$
v_0 \xrightarrow[]{l_0} v_1 \xrightarrow[]{l_1} v_2 \xrightarrow[]{l_2} \ldots \xrightarrow[]{l_{n-2}} v_{n-1} \xrightarrow[]{l_{n-1}} v_n.
$$

\begin{example}[Пример путей графа]
$(0,a,1),(1,a,2) = 0\pi_1 2$  --- путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$.
При этом, $(0,a,1),(1,a,2),(2,b,3),(3,b,2) = 0\pi_2 2$ --- это тоже путь из вершины 0 в вершину 2 в графе $\mathcal{G}_1$, но он не равен $0\pi_1 2$.
\end{example}

Кроме того, нам потребуется отношение, отражающее факт существования пути между двумя вершинами.

\begin{definition}\label{def:reach}
  \textit{Отношение достижимости} в графе:
  $(v_i,v_j) \in P \iff \exists v_i \pi v_j$.
\end{definition}

Отметим, что в некоторых задачах удобно считать по-умолчанию, что $(v_i,v_i) \in P$, однако наше определение такого не допускает. Исправить ситуацию можно явно добавив петли $(v_i,l,v_i)$ для всех вершин.

Один из способов задать граф --- это задать его \textit{матрицу смежности}.

\begin{definition}
  \textit{Матрица смежности} графа $\mathcal{G}=\langle V,E,L \rangle$ --- это квадратная матрица $M$ размера $n \times n$, где $|V| = n$, построенная над алгебраической структурой $\mathbb{G} = (S,\circ\colon S \times S \to S)$, которая конструируется следующим образом.

  \begin{enumerate}
    \item $L \subseteq S$.
    \item $\circ$ --- коммутативная бинарная операция.
    \item Существует $ \mathbb{0} \in (S \setminus L)$ --- нейтральный элемент относительно $\circ$.    
  \end{enumerate}

  При этом $M[i,j] = \bigcirc_{(i,l,j) \in E}l$, где $\bigcirc_\varnothing = \mathbb{0}$.
\end{definition}

Заметим, что наше определение матрицы смежности отличается от классического, в котором матрица является булевой и отражает лишь факт наличия хотя бы одного ребра и. То есть $M[i,j] = 1 \iff \exists e = (i,\_,j) \in E$.

\begin{example}[Пример матрицы смежности неориентированного графа]\label{exmpl:undirectedGraphMatrix}
  Пусть дан следующий неориентированный граф.
  \begin{center}
    \input{figures/graph/graph1.tex}
  \end{center}

$\mathbb{G} = (S,\circ)$ в этом случае конструируется следующим образом. Во-первых, придётся предположить, что $L$ --- множество с одним элементом, скажем $s$, и считать, что все рёбра помечены им\footnote{А раз все рёбра имеют одинаковый заранее известный вес, то можно его и не писать для каждого ребра при задании графа. Поэтому привычное нам изображение получается достаточно логичным.}. Далее, $S = L \cup{\{n\}} = \{s,n\}$, где $n$ --- нейтральный элемент относительно $\circ$. Тогда $\circ$ можно определить поточечно следующим образом.
\begin{itemize}
  \item $s \circ s = s$
  \item $s \circ n = n \circ s = s$
  \item $n \circ n = n$
\end{itemize} 

Таким образом, матрица смежности данного графа выглядит следующим образом:
$$
\begin{pmatrix}
  n & s & s & n \\
  s & n & s & n \\
  s & s & n & s \\
  n & n & s & n
\end{pmatrix}
$$
, что может показаться несколько непривычным. Однако заметим, что построенная нами структура $\mathbb{G} = (\{s,n\}, \circ)$ изоморфна $\mathbb{G}' = (\{1,0\}, \vee)$. При переходе к $\mathbb{G}'$ мы получим привычную нам булеву матрицу смежности: 
  $$
  \begin{pmatrix}
    0 & 1 & 1 & 0 \\
    1 & 0 & 1 & 0 \\
    1 & 1 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix}
  $$
  Заметим, что матрица смежности неориентированного графа всегда симметрична относительно главной диагонали.
\end{example}

\begin{example}[Пример матрицы смежности ориентированного графа]\label{example:diGraph}
  Дан ориентированный граф:
  \begin{center}
  \input{figures/graph/graph2.tex}
  \end{center}

  Построить его булеву матрицу смежности можно применив рассуждения из предыдущего примера (\ref{exmpl:undirectedGraphMatrix}) и выглядеть она будет следующим образом:
  $$
  \begin{pmatrix}
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    1 & 0 & 0 & 1 \\
    0 & 0 & 1 & 0
  \end{pmatrix}
  $$
\end{example}

\begin{example}[Пример матрицы смежности помеченного графа]
  Пусть дан следующий помеченный граф.
  \begin{center}
    \input{figures/graph/graph3.tex}
  \end{center}

  В данном случае $L = \{\{a\},\{b\}\}$, а $\mathbb{G} = ( \{\{a\},\{b\},\{a,b\},\varnothing\} ,\cup)$, где $\varnothing$ --- нейтральный элемент.
  Тогда матрица матрица смежности исходного графа выглядит следующим образом:
  $$
  \begin{pmatrix}
    \varnothing   & \{a\}       & \varnothing & \varnothing \\
    \varnothing   & \varnothing & \{a\}       & \varnothing \\
    \{a\}         & \varnothing & \varnothing & \{a,b\} \\
    \varnothing   & \varnothing & \{b\}       & \varnothing
  \end{pmatrix}
  $$
\end{example}

Необходимо заметить, что свойства $\mathbb{G}$, а значит и детали её построения, зависят от задачи, в рамках которой рассматривается граф. В примерах выше мф строили $\mathbb{G}$ из некоторых общих соображений, не специфицируя решаемую задачу, стараясь получить ожидаемый результат. Далее мы рассмотрим пример, в котором видно, как решаемая задача влияет на построение $\mathbb{G}$.

\begin{example}[Пример матрицы смежности взвешенного графа]\label{example:apspGraph}
  Пусть дан следующий взвешенный граф:
  \begin{center}
    \input{figures/graph/graph4.tex}
  \end{center}

  Будем считать, что веса берутся из $\mathbb{R}$, а решаемая задача --- поиск кратчайших путей между вершинами. В таком случае естественно предположить, что для любой вершины $v_i$ существует петля $v_i,0,v_i$, хоть она явно и не изображена. Далее, $\mathbb{G} = ( \mathbb{R}\cup \{\infty\} , \min)$, где $\infty$ --- нейтральный элемент относительно операции $\min$. 

  В результате мы получим следующую матрицу смежности:
  $$
  \begin{pmatrix}
    0 & -1.4 & \infty & \infty \\
    \infty & 0 & 2.2 & \infty \\
    0.5 & \infty & 0 & 1.85 \\
    \infty & \infty & -0.76 & 0
  \end{pmatrix}
  $$
\end{example}

Мы ввели лишь общие понятия.
Специальные понятия, необходимые для изложения конкретного материала, будут даны в соответствующих главах.

\section{Графы и линейная алгебра}

В данной главе мы рассмотрим некоторые связи\footnote{Связь между графами и линейной алгеброй --- обширная область, в которой можно даже выделить отдельные направления, такие как спектральная теория графов. С точки зрения практики данная связь также подмечена давно и более полно с ней можно ознакомиться, например, в работах~\cite{doi:10.1137/1.9780898719918, Davis2018Algorithm9S}. Кроме этого, много полезной информации можно найти на сайте \url{https://graphblas.github.io/GraphBLAS-Pointers/}.} между графами и операциями над ними и матрицами и операциями над матрицами. 

Как мы видели в предыдущем разделе, достаточно естественное представление графа --- это его матрица смежности. Заметим, что говоря о графе, как о графе с весами из некоторого множества на рёбрах, и о его матрице смежности, как о матрице над некоторой структурой, нужно быть аккуратным.

С одной стороны, когда мы говорим о весах на рёбрах, мы, как правило, ожидаем, что множество из которого берутся веса снабжено и некоторыми операциями. Например, если мы хотим трактовать веса как расстояния, то мы ожидаем, что веса можно складывать. Таким образом, веса, очевидно должны рассматриваться не просто как элементы какого-то множества, но как элементы носителя некоторой алгебраической структуры. 

С другой стороны, алгебраическая структура, задающая веса в графе, и алгебраическая структура, над которой строится матрица смежности данного графа --- не одно и то же. Проще всего это заметить в примере~\ref{example:apspGraph}. Веса на рёбрах в данном случае из $\mathbb{R}$\footnote{В некоторых случаях логично даже требовать, чтобы веса были из $\mathbb{R} \setminus \{0\}$.}, в то время как носитель структуры, над которой построена матрица, содержит ещё и элемент $\infty$, то есть носитель уже $\mathbb{R}\cup\{\infty\}$. Ещё более запутанная ситуация с примером~\ref{example:diGraph}. Матрица смежности содержит булевы значения, в то время как граф, вообще говоря, весов не рёбрах не имеет.

Так как же связаны алгебраическая структура, над которой строится матрица смежности, и структура, определяющая веса на рёбрах? 

Первое, что необходимо уяснить --- это то, что обе структуры зависят от того, в каком контексте мы рассматриваем граф, какую задачу мы собираемся решать. Это естественным образом накладывает ограничения и на носитель и на операции. Например, если мы собираемся обсуждать задачу поиска кратчайших путей, то один из логичных вопросов, которые надо решить, допускаем ли мы отрицательные веса? Далее, раз речь идет о поиске кратчайшего (наименьшего) пути, то нам необходима операция взятия минимума. Далее, нам необходимо уметь получать длину пути на основе длин его составляющих, а значит нам нужна операция сложения весов.

Интуитивно мы ожидаем, что в алгебраической структуре будут те же самые операции (по крайней мере по своему смыслу), что и в структуре для весов. Действительно, задачу мы решаем одну и ту же. Однако аккуратное рассмотрение данного вопроса приводит нас к тому, что формально операции будут всё же разные. Произойдёт это по следующей причине. В графе информация об отсутствии ребра представлена (в каком-то смысле) неявно, однако в матрице смежности все ячейки должны содержать какие-то явные значения. Логичное решение --- расширить множество весов каким-то специальным значением. Так обычно и поступают. Но после этого надо доопределить действие операций над весами до действия на новом множестве (фактически, задать поведение для нового элемента).

В большинстве задач нам будут требоваться две операции, появляющиеся из следующих соображений. Во-первых, изначально у нас есть только рёбра, а дальше мы будем ``собирать'' путь из частей: сперва из рёбер, затем и из других путей. Элементарный шаг здесь --- это соединить две часть пути с общей вершиной в новый путь. При этом необходимо по весам двух подпутей получить вес нового пути. За это будет отвечать операция $\otimes$ на множестве весов\footnote{При первом рассмотрении такой выбор кажется контринтуитивным. Действительно, ведь при соединении путей мы как бы ``складываем'' их веса. Но при более детальном анализе поведения этой операции, в частности, относительно нейтрального элемента, становится понятно, что она ведёт себя очень похоже на умножение. Вероятно, стоит обратить внимание на операцию конкатенации, которая, с одной стороны, ``делает то, что нам нужно'', а с другой, (и неспроста) часто обозначается $\cdot$.}. Во-вторых, нам необходимо как-то обрабатывать ситуации, когда между двумя вершинами существует несколько различных путей. Иными словами, необходимо уметь агрегировать информацию по множеству путей. И за это будет отвечать операция $\oplus$. Таким образом, когда мы говорим о графе, достаточно естественным образом появляется структура $R=(S,\oplus,\otimes)$.

\begin{example} Построим такую структуру для ориентированного графа без весов и задачи достижимости. В качестве $S$ можно взять множество с одним элементом, скажем $s$, и считать, что все рёбра помечены им\footnote{А раз все рёбра имеют одинаковый заранее известный вес, то можно его и не писать для каждого ребра при задании графа. Поэтому привычное нам изображение получается достаточно логичным.}.  

Какое поведение мы ожидаем от $\otimes$? Нас интересует только факт наличия пути, а наличие метки $s$ ровно это обозначает. Таким образом, если мы собираем путь из двух рёбер, то мы получаем путь с весом $s$. Иными словами, $s \otimes s = s$. 

Из аналогичных соображений зададим поведение операции $\otimes$. Сколько бы путей не существовало между двумя вершинами, на важно знать, существует ли хотя бы один или не существует ни одного. То есть $s \oplus s = s$.

В результате получаем, что $R=(\{s\}, \oplus, \otimes)$, где $s \oplus s = s, s \otimes s = s$.

Теперь перейдём к матрице смежности. Так как нам необходимо обозначать факт отсутствия пути, то нам потребуется ещё один элемент. Скажем, $n$. Таким образом, носитель у нас теперь состоит из двух элементов: $S' = \{s,n\}$. Посмотрим, как можно доопределить поведение операций для того, чтобы они корректно обрабатывали новое значение на входе.

Вот этот переход не очевиден.

Умножение должно обрабатывать 
\begin{itemize}
\item $s \otimes s = s$ : если существует путь $i \pi j$ и путь $j \pi k$, то существует путь $i \pi k$.
\item $s \otimes n = n$ : если существует путь $i \pi j$ и не существует пути $j \pi k$, то не существует и пути $i \pi k$.
\item $n \otimes s = n$ : если не существует пути $i \pi j$ и существует путь $j \pi k$, то не существует и пути $i \pi k$.
\item $n \otimes n = n$ : если не существует пути $i \pi j$ и не существует пути $j \pi k$, то не существует и пути $i \pi k$.
\end{itemize}
Предположим, что мы решаем задачу достижимости, а значит нас интересует только ф

Нам просто повезло, что получившаяся структура изоморфна булеву полукольцу. 

\end{example}

 Матрицы --- рёбра. Операции над матрицами --- операции над рёбрами. 

Про умножение. Конкатенация рёбер, выбор из нескольких возможных вариантов: как раз две операции в полукольце. Красивая картинка про то, как умножение матриц работает с рёбрами. 

Про Кронекера и произведение графов.

\section{Задачи поиска путей}

Одна из классических задач анализа графов --- это задача поиска путей между вершинами с различными ограничениями.

При этом, возможны различные постановки задачи.
С одной стороны, по тому, что именно мы хотим получить в качестве результата:
\begin{itemize}
\item Наличие хотя бы одного пути, удовлетворяющего ограничениям, в графе. В данном случае не важно, между какими вершинами существует путь, важно лишь наличие его в графе.
\item Наличие пути, удовлетворяющего ограничениям, между некоторыми вершинами: задача достижимости.
      При данной постановке задачи, нас интересует ответ на вопрос достижимости вершина $v_1$ из вершины $v_2$ по пути, удовлетворяющему ограничениям.
      Такая постановка требует лишь проверить существование пути, но не обязательно его предоставлять в явном виде.
\item Поиск одного пути, удовлетворяющего ограничениям: необходимо не только установить факт наличия пути, но и  предъявить его. При этом часто подразумевается, что возвращается любой путь, являющийся решением, без каких-либо дополнительных ограничений. Хотя, например, в некоторых задачах дополнительное требование простоты или наименьшей длинны выглядит достаточно естественным.
\item Поиск всех путей: необходимо предоставить все пути, удовлетворяющие заданным ограничениям.
\end{itemize}

С другой стороны, задачи различаются ещё и по тому, как фиксируются множества стартовых и конечных вершин.
Здесь возможны следующие варианты:
\begin{itemize}
\item от одной вершины до всех,
\item между всеми парами вершин,
\item межу фиксированной парой вершин,
\item между двумя множествами вершин.
\end{itemize}

Стоит отметить, что последний вариант является самым общим и остальные --- лишь его частные случаи. 
Однако этот вариант часто выделяют отдельно, подразумевая, что остальные, выделенные, варианты в него не включаются. В итоге мы можем сформулировать прямое произведение различных постановок задач о поиске путей, перебирая возможные варианты желаемого результата и фиксируя стартовые и финальные множества разными способами.

Часто при поиске путей на них накладывают дополнительные ограничения. Например, можно потребовать, чтобы пути были простыми или не проходили через определённые вершины.
Ограничение, имеющее важное прикладное значение, --- минимальность длины искомого пути.
Одна из важных задач, имеющих как прикладное, так и теоретическое значение --- \textit{поиск кратчайших путей в графе между всеми парами вершин(англ. APSP --- all-pairs shortest paths)}. Рассмотрим её более подробно. Тем более, что данная задача в определённом смысле близка к задаче, которая будет основной в данной работе, и из алгоритмов для APSP можно почерпнуть идеи для алгоритмов решения задачи поиска путей с ограничениями в терминах формальных языков.


\section{APSP и транзитивное замыкание графа}

Заметим, что отношение достижимости (\ref{def:reach}) является транзитивным.
Действительно, если существует путь из $v_i$ в $v_j$ и путь из $v_j$ в $v_k$, то существует путь из $v_i$ в $v_k$.

\begin{definition}
  \textit{Транзитивным замыканием графа} называется транзитивное замыкание отношения достижимости по всему графу.
\end{definition}

Как несложно заметить, транзитивное замыкание графа --- это тоже граф.
Более того, если решить задачу поиска кратчайших путей между всеми парами вершин, то мы построим транзитивное замыкание.

Поэтому сразу рассмотрим алгоритм Флойда-Уоршелла~\cite{Floyd1962, Bernard1959, Warshall1962}, который является общим алгоритмом поиска кратчайших путей. Данный алгоритм умеет обрабатывать рёбра с отрицательными весами, чего не может, например, алгоритм Дейкстры. Его сложность: $O(n^3)$, где $n$ --- количество вершин в графе. При этом, данный алгоритм легко упростить до алгоритма построения транзитивного замыкания. Псевдокод алгоритма представлен на листинге~\ref{lst:algoFloydWarxhall}.

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Алгоритм Флойда-Уоршелла}
\label{lst:algoFloydWarxhall}
\Function{FloydWarshall}{$\mathcal{G}$}
    \State{$M \gets$ матрица смежности $\mathcal{G}$}
    \State{$n \gets$ $|V(\mathcal{G})|$}
    \For{k = 0; k < n; k++}
      \For{i = 0; i < n; i++}
        \For{j = 0; j < n; j++}
          \State{$M[i,j] \gets M[i,j] \oplus (M[i,k] \otimes M[k,j])$}
        \EndFor
      \EndFor
    \EndFor
\State \Return $M$
\EndFunction
\end{algorithmic}
\end{algorithm}

В зависимости от того, над каким полукольцом построена матрица смежности (какого рода веса на рёбрах графа) данный алгоритм может решать несколько разные задачи. Например, если возьмём тропическое полукольцо $(\mathbb{R}_{+\infty}, \min, +)$, то получим алгоритм для поимка кратчайших путей. Если же возьмём булево полукольцо, то получим алгоритм для построения транзитивного замыкания графа.

\begin{example}[Транзитивное замыкание графа]
  Пусть дан следующий граф:
  \begin{center}
    \input{figures/graph/graph2.tex}
  \end{center}

  Его матрица смежности:
  $$ M = 
  \begin{pmatrix}
    1 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 \\
    1 & 0 & 1 & 1 \\
    0 & 0 & 1 & 1
  \end{pmatrix}
  $$

  Здесь мы считаем, что отношение достижимости рефлексивно: все диагональные элементы матрицы $M$ равны 1, хотя петель у вершин нету. 

  Воспользовавшись алгоритмом из листинга~\ref{lst:algoFloydWarxhall}, специализированного на случай булева полукольца, можно получить следующую матрицу смежности.

  $$ M' = 
  \begin{pmatrix}
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 1
  \end{pmatrix}
  $$

  А значит, транзитивным замыканием исходного графа является полный граф и он выглядит следующим образом.
  
  \begin{center}
    \input{figures/graph/graph5.tex}
  \end{center}

\end{example}

Заметим, что рефлексивность отношения (значения элементов на главной диагонали матрицы смежности) непосредственно связана с особенностями решаемой задачи. Например, если говорить о кратчайших расстояниях, то кажется естественным считать расстояние от вершины до самой себя равной нулю. Однако для задачи транзитивного замыкания это уже не столь естественное предположение и часто отдельно говорят от рефлексивно-транзитивном замыкании, которое отдельно явным образом привносит рефлексивность (петли, диагональные элементы матрицы смежности).



\section{APSP и произведение матриц}

Алгоритм Флойда-Уоршелла можно переформулировать в терминах перемножения матриц над тропическим полукольцом.

Пусть $D_k$ --- матрица кратчайших путей, состоящих не более чем из $k$ рёбер. То есть $D_k[i,j]$ --- это длина кратчайшего пути из вершины $i$ в вершину $j$, такого, что он состоит не более чем из $k$ ребер. Если такого пути нет, то $D_k[i,j] = \infty$.

Таким образом, $D_1 = M$, где $M$ --- это матрица смежности исходного графа, а решением APSP является $D_{n-1}$.

\begin{center}
    $D(1) = M$ \\
    $D(2) = D(1) \cdot M = M^2$ \\
    $D(3) = D(2) \cdot M = M^3$ \\
    $\dots$ \\
    $D(n-1) = D(n-2) \cdot M = M^{n-1}$ \\
\end{center}

Итак, мы можем решить APSP за $O(n K(n))$, где $K(n)$ --- сложность алгоритма умножения матриц.

Сразу заметим, что, например, $D_3$ считать не обязательно, т.к. можем посчитать $D_4$ как $D_2 \cdot D_2$.
Поэтому:

\begin{center}
    $D_1 = M$ \\
    $D_2 = M^2 = M \cdot M$ \\
    $D_4 = M^4 = M^2 \cdot M^2$ \\
    $D_8 = M^8 = M^4 \cdot M^4$ \\
    $\dots$ \\
    $D_{2^{\log(n-1)}} = M^{2^{\log(n-1)}} = M^{2^{\log(n-1)} - 1} \cdot M^{2^{\log(n-1)} - 1}$ \\
    $D_{n-1} = D_{2^{\log(n-1)}}$ \\
\end{center}

Теперь вместо $n$ итераций нам нужно $\log{n}$. В итоге, сложность --- $O(\log{n} K(n))$.
Данный алгоритм называется \textit{repeated squaring}\footnote{Пример решения APSP с помощью repeated squaring: \url{http://users.cecs.anu.edu.au/~Alistair.Rendell/Teaching/apac_comp3600/module4/all_pairs_shortest_paths.xhtml}}.


Таким образом, APSP сводится к умножению матриц над полукольцом, что, к сожалению, не позволяет этим путём получить истинно субкубический алгоритм для задачи. тем не менее, позволяет получить слегка субкубический. Приведем некоторые работы по APSP для ориентированных графов с вещественными весами (здесь $n$ --- количество вершин в графе):
\begin{itemize}
    \item M.L. Fredman (1976) --- $O(n^3(\log \log n / \log n)^\frac{1}{3})$ --- использование дерева решений~\cite{FredmanAPSP1976}
    \item W. Dobosiewicz (1990) --- $O(n^3 / \sqrt{\log n})$ --- использование операций на Word Random Access Machine~\cite{Dobosiewicz1990}
    \item T. Takaoka (1992) --- $O(n^3 \sqrt{\log \log n / \log n})$ --- использование таблицы поиска~\cite{Takaoka1992}
    \item Y. Han (2004) --- $O(n^3 (\log \log n / \log n)^\frac{5}{7})$~\cite{Han2004}
    \item T. Takoaka (2004) --- $O(n^3 (\log \log n)^2 / \log n)$~\cite{Takaoka2004}
    \item T. Takoaka (2005) --- $O(n^3 \log \log n / \log n)$~\cite{Takaoka2005}
    \item U. Zwick (2004) --- $O(n^3 \sqrt{\log \log n} / \log n)$~\cite{Zwick2004}
    \item T.M. Chan (2006) --- $O(n^3 / \log n)$ --- многомерный принцип ``разделяй и властвуй''~\cite{Chan2008}
    \item и др.
\end{itemize}

Таким образом, вопрос о субкубических алгоритмах решения APSP всё ещё открыт~\cite{Chan2010}.




%\section{Вопросы и задачи}
%\begin{enumerate}
%  \item Реализуйте абстракцию полукольца, позволяющую конструировать полукольца с произвольными операциями.
%  \item Реализуйте алгоритм произведения матриц над произвольным полукольцом. Используйте результат решения предыдущей задачи.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм построения транзитивного замыкания через произведение матриц.
%  \item Используя результаты предыдущих задач, реализуйте алгоритм решения задачи APSP для ориентированного через произведение матриц.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для CPU, решите задачу APSP для ориентированного графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу построения транзитивного замыкания графа.
%  \item Используя существующую библиотеку линейной алгебры для GPGPU, решите задачу APSP для ориентированного графа.
%  \item Сравните произволительность решений предыдущих задач
%\end{enumerate}
