\chapter{Поиск путей с регулярными ограничениями}

\section{Достижимость между всеми парами вершин}

Через тензорное произведение.

Классическое построение пересечения автоматов строит их тензорное произведение.

Так как мы хотим отвечать ещё и на вопрос о достижимости, что нам надо ещё и транзитивное замыкание посчитать.

\section{Достижимость с несколькими источниками}

Достижимость от нескольких стартовых вершин через обход в ширину, основанный на линейной алгебре~\cite{9286186}.

В классической версии обхода в ширину, основанного на линейной алгебре, используется вектор, куда записывается фронт обхода графа. Так, один раз перемножая этот вектор на матрицу смежности графа, можно совершать один шаг в обходе графа. Покажем на примере, как данный метод может быть использован, когда мы накладываем формальные ограничения на путь в графе. 

\begin{example}
  \begin{align}
    \label{input_rpq}
        \input{figures/graph/graph0.tex}
    \end{align}
  
  Возьмём граф, представленный на рисунке~\ref{input_rpq}.
  Его матрица смежности имеет следующий вид.
  \[ G_2 =
  \begin{pmatrix}
  . & [a] & . & . \\
  . & . & [a] & . \\
  [a] & . & . & [b] \\
  . & . & [b] & .
  \end{pmatrix}
  \]
  
  Или, если представить её в булевом виде.
  \begin{alignat*}{7}
  & &&G_{0\_A} &&= \begin{pmatrix}
  0 & 1       & 0 & 0       \\
  0 & 0 & 1       & 0 \\
  1  & 0 & 0 & 0       \\
  0       & 0 & 0 & 0 \\
  \end{pmatrix} \ \ \ \ &&G_{0\_B} &&= \begin{pmatrix}
  0 & 0       & 0 & 0       \\
  0       & 0 & 0       & 0 \\
  0  & 0 & 0 & 1       \\
  0       & 0 & 1 & 0 \\
  \end{pmatrix}
  \end{alignat*}

  Зададим формальные ограничения с помощью регулярного выражения $ba$, которое представляется автоматом из трех последовательных состояний.
  Нам хочется совершать обход по графу и автомату одновременно, поэтому также представим автомат в булевом виде.
  \begin{alignat*}{7}
    & &&R_{0\_A} &&= \begin{pmatrix}
      0 & 0 & 0 \\
      0 & 0 & 0 \\
      0 & 1 & 0 
      \end{pmatrix} \ \ \ \ &&R_{0\_B} &&= \begin{pmatrix}
        0 & 0 & 0 \\
        1 & 0 & 0 \\
        0 & 0 & 0 
        \end{pmatrix}
    \end{alignat*}

  Для синхронизации обхода составим блочно---диагональную матрицу как прямую сумму матриц $R_{0\_A}$, $G_{0\_A}$ и $R_{0\_B}$, $G_{0\_B}$ соответственно.
  \begin{alignat*}{7}
    & &&D_{0\_A} &&= \begin{pmatrix}
      0 & 0 & 0 & 0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 & 0 & 0 & 0 \\
      0 & 1 & 0 & 0 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1 & 0 & 0 & 0 \\
      0 & 0 & 0 & 0 & 0 & 0 & 0 
      \end{pmatrix} \ \ \ \ &&D_{0\_B} &&= \begin{pmatrix}
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 \\
        0 & 0 & 0 & 0 & 0 & 1 & 0 
        \end{pmatrix}
    \end{alignat*}

  Допустим, что стартовыми вершинами в графе будут выбраны вершины 0 и 3.
  Теперь создадим вектор $v = $ \fbox{1 1 1} \fbox{1 0 0 1}, где в первой части стоят три единицы, соответствующие каждому состоянию автомата, в котором мы можем находиться. Во второй части содержится фронт обхода графа, на данном шаге это стартовые вершины.
  
  Получим новый фронт.
  \begin{alignat*}{7}
    & \begin{matrix}
      \fbox{1 1 1} \fbox{1 0 0 1}
      \end{matrix}  && \begin{pmatrix}
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 
        \end{pmatrix} &&= \begin{matrix}
          \fbox{0 1 0} \fbox{0 1 0 0} 
          \end{matrix}
    \end{alignat*}

  \begin{alignat*}{7}
    & \begin{matrix}
      \fbox{1 1 1} \fbox{1 0 0 1}
      \end{matrix}  && \begin{pmatrix}
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 \\
        0 & 0 & 0 & 0 & 0 & 1 & 0 
        \end{pmatrix} &&= \begin{matrix}
          \fbox{1 0 0} \fbox{0 0 1 0}
          \end{matrix}
    \end{alignat*}

    Тем самым, \fbox{0 1 0} \fbox{0 1 0 0} + \fbox{1 0 0} \fbox{0 0 1 0} = \fbox{1 1 0} \fbox{0 1 1 0}. То есть в наш фронт \fbox{0 1 1 0} попали вершины 1 и 2.
    Однако вершина 1 лишняя, так как на первом шаге мы должны были пройти только по ребрам с меткой $b$. Это произошло, потому что в векторе $v$ не хранится информация о текущем состоянии в автомате.

    Для этого в разработанном алгоритме предлагается расклеить $v$ в матрицу из трех векторов.
    \begin{alignat*}{7}
      & &&M &&=\begin{matrix}
        \fbox{1 0 0} \fbox{1 0 0 1} \\ 
        \fbox{0 1 0} \fbox{1 0 0 1} \\
        \fbox{0 0 1} \fbox{1 0 0 1}
            \end{matrix}
      \end{alignat*}

    И совершать обход следующим образом.
    \begin{alignat*}{7}
      & \begin{matrix}
        \fbox{1 0 0} \fbox{1 0 0 1} \\ 
        \fbox{0 1 0} \fbox{1 0 0 1} \\
        \fbox{0 0 1} \fbox{1 0 0 1}
          \end{matrix}  && \begin{pmatrix}
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 1 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 1 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 1 & 0 \\
          0 & 0 & 0 & 1 & 0 & 0 & 1 \\
          0 & 0 & 0 & 0 & 0 & 1 & 0 
          \end{pmatrix} &&= \begin{matrix}
            \fbox{0 0 0} \fbox{0 1 0 0} \\ 
            \fbox{0 0 0} \fbox{0 1 0 0} \\
            \fbox{0 1 0} \fbox{0 1 0 0}
            \end{matrix}
      \end{alignat*}
    
    \begin{alignat*}{7}
      & \begin{matrix}
        \fbox{1 0 0} \fbox{1 0 0 1} \\ 
        \fbox{0 1 0} \fbox{1 0 0 1} \\
        \fbox{0 0 1} \fbox{1 0 0 1}
          \end{matrix}  && \begin{pmatrix}
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 0 & 0 & 0 & 0 & 1 \\
          0 & 0 & 0 & 0 & 0 & 1 & 0 
          \end{pmatrix} &&= \begin{matrix}
            \fbox{0 0 0} \fbox{0 0 1 0} \\ 
            \fbox{1 0 0} \fbox{0 0 1 0} \\
            \fbox{0 0 0} \fbox{0 0 1 0}
            \end{matrix}
      \end{alignat*}
\end{example}

Видно, что к вершине 2 можно прийти из нулевого состояния автомата \fbox{1 0 0} \fbox{0 0 1 0}, а к вершине 1 из первого \fbox{0 1 0} \fbox{0 1 0 0}.

Теперь левая часть матрицы M неизменяема, так как каждая её строчка содержит информацию о том, из какого состояния автомата достигаются вершины фронта.
Правая часть матрицы $M$ содержит этот фронт.


Перейдем к формальному описанию алгоритма.


Алгоритм принимает на вход граф $\mathcal{G}$, детерминированный конечный автомат $\mathcal{R}$, описывающий регулярную грамматику, и множество начальных вершин $V_{src}$ графа.

Граф $\mathcal{G}$ и автомат $\mathcal{R}$ можно представить в виде булевых матриц смежности. Так, в виде словаря для каждой метки графа заводится булева матрица смежности, на месте $(i, j)$ ячейки которой стоит 1, если $i$ и $j$ вершины графа соединены ребром данной метки. Такая же операция проводится для автомата грамматики $\mathcal{R}$.

Далее, мы оперируем с двумя словарями, где ключом является символ метки ребра графа или символ алфавита автомата, а значением --- соответствующая им булевая матрица.

Для каждого символа из пересечения этих множеств строится матрица $\mathfrak{D}$, как прямая сумма булевых матриц. То есть, строится матрица $\mathfrak{D} = Bool_{\mathcal{R}_a} \bigoplus Bool_{\mathcal{G}_a}$, которая определяется как

\begin{equation}
\mathfrak{D} = 
  \left[
    \begin{matrix}
        Bool_{\mathcal{R}_a} & 0\\
        0 & Bool_{\mathcal{G}_a}
    \end{matrix}
  \right]
\end{equation}

Где $\mathcal{R}_{a}$ и $\mathcal{G}_{a}$ матрицы смежности соответствующих символов автомата грамматики $\mathcal{R}$ и графа $\mathcal{G}$ для символа $a \in A_\mathcal{R} \cap A_\mathcal{G}$, $A_\mathcal{R} \cap A_\mathcal{G}$ --- пересечение алфавитов. Такая конструкция позволяет синхронизировать алгоритм обхода в ширину одновременно для графа и грамматики.

Далее вводится матрица $M$, хранящая информацию о фронте обхода. Она нужна для выделения множества пройденных вершин и не допускает зацикливание алгоритма.
\begin{equation}
M^{k \times (k + n)} =
  \left[
    \begin{matrix}
        Id_k & Matrix_{k \times n }
    \end{matrix}
  \right]
\end{equation}

Где $Id_k$ --- единичная матрица размера $k$, $k$ --- количество вершин в автомате $\mathcal{R}$, $Matrix_{k \times n }$ --- матрица, хранящая в себе маску пройденных вершин в автомате графа, $n$ --- количество вершин в графе $\mathcal{G}$.

\subsection{Выходные данные}

На выходе строится множество $\mathcal{P}$ пар вершин $(v, w)$ графа $\mathcal{G}$ таких, что вершина $w$ достижима из множества начальных вершин, при этом $v \in V_{src}$, $w \not\in V_{src}$. Это множество представляется в виде матрицы размера $|V|\times|V|$, где $(i,j)$ ячейка содержит 1, если пара вершин с индексами $(i, j) \in \mathcal{P}$.

\subsection{Процесс обхода графа}

Алгоритм обхода заключается в последовательном умножении матрицы $M$ текущего фронта на матрицу $\mathfrak{D}$. В результате чего, находится матрица $M'$ содержащая информацию о вершинах, достижимых на следующем шаге. Далее, с помощью операций перестановки и сложения векторов $M'$ преобразуется к виду матрицы $M$ и присваивается ей. Итерации продолжаются пока $M'$ содержит новые вершины, не содержащиеся в $M$. На листинге~\ref{BFSRPQ1} представлен этот алгоритм.

\begin{algorithm}[t]
  \caption{Алгоритм достижимости в графе с регулярными ограничениями на основе поиска в ширину, выраженный с помощью операций матричного умножения}\label{BFSRPQ1}
  \begin{algorithmic}[1]
    \Procedure{BFSBasedRPQ}{$\mathcal{R}=\langle Q, \Sigma, P, F, q \rangle,\mathcal{G}=\langle V, E, L \rangle, V_{src}$}
    \State $\mathcal{P}\gets~${Матрица смежности графа}
    \State $\mathfrak{D}\gets Bool_\mathcal{R} \bigoplus Bool_\mathcal{G}$\Comment{Построение матриц $\mathfrak{D}$}
    \State $M\gets CreateMasks(|Q|,|V|)$ \Comment{Построение матрицы $M$}
    \State $M'\gets SetStartVerts(M, V_{src})$  \Comment{Заполнение нач. вершин}
    
    \While{Матрица~$M$~меняется}{}
      \State $M\gets M'\langle\neg M\rangle$\Comment{Применение комплементарной маски}
      \ForAll{$a\in (\Sigma \cap L)$}
        \State $M'\gets M~$any.pair$~\mathfrak{D}$
        \Comment{Матр. умножение в полукольце}
        \State $M'\gets TransformRows(M')$\label{TransformRows}
        \Comment{Приведение $M'$ к виду $M$}
      \EndFor
        \State {$Matrix\gets extractRightSubMatrix(M')$}
        \State $V\gets Matrix.reduceVector()$ \Comment{Сложение по столбцам}
        \For{$k \in 0\dots|V_{src}|-1$}
            \State $W\gets\mathcal{P}.getRow(k)$
            \State $\mathcal{P}.setRow(k, V+W)$
      \EndFor
    \EndWhile
    \State \textbf{return} $\mathcal{P}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

В алгоритме~\ref{BFSRPQ1}, в~\ref{TransformRows} строке происходит трансформация строчек в матрице $M'$. Это делается для того, чтобы представить полученную во время обхода матрицу $M'$, содержащую новый фронт, в виде матрицы $M$. Для этого требуется так переставить строчки $M'$, чтобы она содержала корректные по своему определению значения. То есть, имела единицы на главной диагонали, а все остальные значения в первых $k$ столбцах были нулями. Подробнее эта процедура описана в листинге~\ref{AlgoTransformRows}.

\begin{algorithm}[H]
  \caption{Алгоритм трансформации строчек}\label{AlgoTransformRows}
  \begin{algorithmic}[1]
    \Procedure{TransformRows}{$M$}
        \State{$T \gets extractLeftSubMatrix(M)$}
        \State{$Ix, Iy \gets$ итераторы по индексам ненулевых элементов $T$}
        \For{$i \in 0\dots|Iy|$}
            \State{$R\gets M.getRow(Ix[i])$}
            \State{$M'.setRow(Iy[i], R + M'.getRow(Iy[i]))$}
        \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\pagebreak

\subsection{Модификации алгоритма}

Рассмотрим $V_{src}$ --- множество начальных вершин, состоящее из $r$ элементов. Для каждой начальной вершины $v_{src}^i \in V_{src}$ отметим соответствующие индексы в матрице $M$ единицами, получив матрицу $M(v_{src}^i)$,  и построим матрицу $\mathfrak{M}$ следующим образом.

\begin{equation}
\mathfrak{M}^{(k*r) \times (k + n)} =
  \left[
    \begin{matrix}
        M(v_{src}^1) \\
        M(v_{src}^2) \\ 
        M(\dots) \\
        M(v_{src}^r) \\
    \end{matrix}
  \right]
\end{equation}

Матрица $\mathfrak{M}$ собирается из множества матриц $M(v_{src}^i)$ и позволяет хранить информацию о том, из какой начальной вершины достигаются новые вершины во время обхода. 

\begin{algorithm}[t]
  \caption{Модификация алгоритма для поиска конкретной исходной вершины}\label{BFSRPQ2}
  \begin{algorithmic}[1]
    \Procedure{BFSBasedRPQ}{$\mathcal{R}=\langle Q, \Sigma, P, F, q \rangle,\mathcal{G}=\langle V, E, L \rangle, V_{src}$}
    \State $\mathcal{P}\gets~${Матрица смежности графа}
    \State $\mathfrak{D}\gets Bool_\mathcal{R} \bigoplus Bool_\mathcal{G}$
    \State $\mathfrak{M}\gets CreateMasks(|Q|,|V|)$
    \State $\mathfrak{M}'\gets SetStartVerts(\mathfrak{M}, V_{src})$  
    
    \While{Матрица~$\mathfrak{M}$~меняется}{}
      \State $\mathfrak{M}\gets \mathfrak{M}'\langle\neg\mathfrak{M}\rangle$
      \ForAll{$a\in (\Sigma \cap L)$}
        \State $\mathfrak{M}'\gets \mathfrak{M}~$any.pair$~\mathfrak{D}$
        \ForAll{$M \in \mathfrak{M}'$}
            \State $M\gets TransformRows(M)$
        \EndFor
      \EndFor
      \ForAll{$M_k \in \mathfrak{M}'$}
        \State $Matrix\gets extractSubMatrix(M)$
        \State $V\gets Matrix.reduceVector()$
        \State $W\gets\mathcal{P}.getRow(k)$
        \State $\mathcal{P}.setRow(k, V+W)$
      \EndFor
    \EndWhile
    \State \textbf{return} $\mathcal{P}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

В листинге~\ref{BFSRPQ2} представлен модифицированный алгоритм. Основное его отличие заключается в том, что для каждой достижимой вершины находится конкретная исходная вершина, из которой начинался обход.

Таким образом, алгоритмы~\ref{BFSRPQ1}~и~\ref{BFSRPQ2} решают сформулированные в пункте \ref{sec:3.3} задачи достижимости.

