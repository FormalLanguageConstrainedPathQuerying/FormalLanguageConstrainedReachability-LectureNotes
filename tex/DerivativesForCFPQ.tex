\chapter{Производные для КС запросов}\label{chpt:CFPQ_Derivatives}

В данной главе мы рассмотрим производные Бжозовского и их возможное применение.

\section{Производные}

Впервые производные формальных языков были определены в 1964 году учёным Янушем Бжозовским (в честь него они и были названы). Он определил это понятие для регулярных языков, предложил алгоритм для вычисления производной обобщенного регулярного выражения, также Бжозовский занимался исследованием свойств производных {\cite{Brzozowski1964}}. 

Изначально всё начиналось с производных регулярных языков, и в главе мы в основном будем говорить именно о них.

Рассмотрим формальное определение производной произвольного языка:

\begin{definition}
    \textit{Производной языка $\mathcal{L}$ по символу а} называется язык $\mathcal{L'} = \partial_{a}(\mathcal{L}) = \{w \mid aw \in \mathcal{L}\}$, где:
    \begin{itemize}
        \item $\mathcal{L} \subseteq \{w \mid w \in \Sigma^*\}$ --- произвольный язык над алфавитом $\Sigma$
        \item $a \in \Sigma$ --- символ, по которому берётся производная
    \end{itemize}
    То есть фактически производная языка --- это суффиксы слов, начинающихся на символ, по которому язык дифференцируется.
\end{definition}

\begin{example}[Производные языка]
Рассмотрим язык $\mathcal{L} = \{pen, plain, day, pray\}$ и несколько языков, порождённых от него с помощью дифференцирования: 
\begin{enumerate}
    \item $\mathcal{L'} = \partial_{p}(\mathcal{L}) = \{en, lain, ray\}$
    \item $\mathcal{L''} = \partial_{e}(\mathcal{L'}) = \{n\}$
    \item $\mathcal{L'''} =\partial_{n}(\mathcal{L''}) = \{\varepsilon\}$
\end{enumerate}
\end{example}

\section{Принадлежность языку}

С помощью производных ествественным образом можно проверять принадлежность слова регулярному языку.
Есть регулярное выражение $R$ и язык, порожденный этим регулярным выражением $L(R)$. Возьмём произвольное слово $w$ и зададимся вопросом: $w \in L(R)$? 

Пусть $w = a_{0}a_{1}... a_{n-1}$, а новый язык $\mathcal{L'}$ получен последовательным дифференцирование исходного языка $L(R)$ по каждому из символов слова $w$, то есть $\mathcal{L'} = \partial_{a_{n-1}}(...\partial_{a_{1}}(\partial_{a_{0}}(L(R)))...)$. В таком случае принадлежность $w$ языку $L(R)$ определяется наличием пустого слова в итоговом языке: $\varepsilon \in \mathcal{L'} \Rightarrow w \in L(R)$. 

\begin{example}
Дан язык $\mathcal{L} = \{pen, plain, day, pray\}$. Принадлежат ли данному языку слова  $pen$, $pet$?
\begin{itemize}
    \item $\partial_{p}(\mathcal{L}) = \{en, lain, ray\} \Rightarrow \partial_{e}(\partial_{p}(\mathcal{L})) = \{n\} \Rightarrow \partial_{n}(\partial_{e}(\partial_{p}(\mathcal{L}))) = \{\varepsilon\}$. А значит, $pen \in \mathcal{L}$
    \item $\partial_{p}(\mathcal{L}) = \{en, lain, ray\} \Rightarrow \partial_{e}(\partial_{p}(\mathcal{L})) = \{n\} \Rightarrow \partial_{t}(\partial_{e}(\partial_{p}(\mathcal{L}))) = \emptyset$. Значит, $pet \notin \mathcal{L}$
\end{itemize}

\end{example}

Описанный выше механизм является основной идеей всех алгоритмом, которые стоятся на производных. 

\section{Построение производных}

Концептуально понятно, как выглядят производные, но хотелось бы уметь считать их алгоритмически, причём сохраняя конструктивное представление языка. Например, для КС грамматики, вычисляя её производную, строится другая КС грамматика.

Рассмотрим алгоритм вычисления производной для регулярных языков, которые представлены как регулярные выражения. Пусть $r_{1}$ и $r_{2}$ ---  два регулярных выражения, $a$ --- произвольный терминальный символ. Определим вспомогательную функцию N --- Nullable, которая проверяет язык на содержание в нём пустого слова $\varepsilon$:

\begin{align*}
  N(\varepsilon) &= true \\
  N(a) &= false \\ 
  N(r_{1} \cdot r_{2}) &= N(r_{1}) \land N(r_{2}) \\
  N(r_{1} \mid r_{2}) &= N(r_{1}) \lor N(r_{2}) \\
  N(r^*) &= true
\end{align*}

Теперь мы готовы перейти непосредственно к вычислению производной по символу $a$: 

\begin{align*}
  \partial_{a}(\emptyset) &= \emptyset \\
  \partial_{a}(\varepsilon) &= \emptyset \\ 
  \partial_{a}(b) &= \begin{cases} 
  \emptyset, & \mbox{if } a \neq b \\ 
  \varepsilon, & \mbox{otherwise} \end{cases} \\
  \partial_{a}(r_{1} \cdot r_{2}) &= \begin{cases} 
  \partial_{a}(r_{1}) \cdot r_{2} \mid \partial_{a}(r_{2}) & \mbox{if } N(r_{1}) = \mbox{true} \\ 
  \partial_{a}(r_{1}) \cdot r_{2}, & \mbox{otherwise} \end{cases} \\
  \partial_{a}(r_{1} \mid r_{2}) &= \partial_{a}(r_{1}) \mid \partial_{a}(r_{2}) \\
  \partial_{a}(r^*) &= \partial_{a}(r) \cdot r^*
\end{align*}

Все правила, за исключением, может быть, последнего, достаточно тривиальны. Последнее доказывается по индукции, но особо любопытные могут руками вычислить для первой пары слагаемых и рассмотреть закономерность.

Приводить подобный алгоритм для КС языков мы не будем, но важно понимать, что он есть, и идея не сильно отличается от алгоритма для регулярных языков.

\section{Задача достижимости}
Используя производные, можно решать задачу достижимости. Даны регулярный запрос и граф, для простоты зафиксируем стартовую вершину. Для решения задачи достижимости при помощи производных рекурсивно выполняем следующее:

\begin{enumerate}
    \item При переходе по ребру дифференцируем запрос по метке на нём
    \item Передаём эту производную вдоль ребра в следующую вершину
    \item В этой следующей вершине производная запоминается, если ранее не встречалось регулярное выражение, которое порождается тот же язык (таким образом формируется набор регулярных выражений, порождающих языки, которые уже передовались на вершину). В противном случае -- терминируемся.
\end{enumerate}

После того, как вышеописанный алгоритм завершился для всех вершин, проходим по ним и ищем в их наборах Nullable регулярные выражения, которые и сигнализируют о том, что путь из стартовой веришны в данную вершину существует.

Некоторые замечания:

\begin{itemize}
    \item Если алгоритм запускается не на одной вершине, а сразу на нескольких, передаются вдоль рёбер не просто производные, а пары: (стартовая вершина, производная).
    \item Что мы в общем случае делаем с циклами, чтобы задача считалась алгоритмически? Разбиваем граф на наибольшие по включению компоненты сильной связности с связями между ними, стягиваем компоненты. Тогда граф превращается в дек, в котором проблем с нетерминируемостью нет, а с компонентами сильной связности разбираемся отдельно. Для этого достаточно рассмотреть одну такую компоненту: если есть цикл, то по нему можно ходить, только если в запросе есть применение звезды Клини, и, как нам уже известно, производная запроса данной операции --- конечная конструкция. В итоге мы сможем, переходя по вершинами, прийти к моменту, когда внутри компоненты в наборах производных вершин новых элементов не будет прибавляться, а значит, мы можем закончить алгоритм.
\end{itemize}

Рассмотрим решение задачи достижимости с помощью производных на конкретном примере:

\begin{example}
Даны регулярный запрос $R = a^* \mid a^* \cdot b$ и граф $\mathcal{G}$:
    
    \begin{center}
        \begin{tikzpicture}[shorten >=1pt,on grid,auto]
        \node[state] (q_0)   {$0$};
        \node[state] (q_1) [above right=of q_0] {$1$};
        \node[state] (q_2) [right=of q_0] {$2$};
        \node[state] (q_3) [right=of q_2] {$3$};
        \path[->]
        (q_0) edge  node {a} (q_1)
        (q_1) edge  node {a} (q_2)
        (q_2) edge  node {a} (q_0)
        (q_2) edge[bend left, above]  node {b} (q_3)
        (q_3) edge[bend left, below]  node {b} (q_2);
        \end{tikzpicture}
    \end{center}

Стартовая веришина --- вершина графа $\mathcal{G}$ с индексом 0. Хотим проверить существование путей из вершины 0 до других вершин графа по $R$. Заведем 4 множества, в которых будем хранить регулярные выражения, передаваемые в конкретную вершину: $M_{0}$ --- для вершины с индексом 0, $M_{1}$ --- для вершины с индексом 1 и так далее. 

\begin{enumerate}
    \item Начинаем идти вдоль ребра с меткой $a$ из вершины 0 в 1. Дифференцируем наш запрос по данной метке: $\partial_{a}(R) = \partial_{a}(a^* \mid a^* \cdot b) = \partial_{a}(a^*) \mid \partial_{a}(a^* \cdot b) = \partial_{a}(a) \cdot a^* \mid \partial_{a}(a^*) \cdot b \mid \partial_{a}(b) = a^* \mid a^* \cdot b = R$. Запоминаем эту производную в $M_{1}$:  $M_{1} = \{R\}$ 
    \item Аналогично идём из вершины 1 в вершину 2 по $a$. В итоге в $M_{2}$ также будет находиться R.
    \item В вершине 2 параллельно идём по метке $a$ в 0 и по метке $b$ в вершину с индексом 3. 
    \begin{enumerate}
        \item В первом потоке при переходе по $a$ мы дифференцируем $R$ по a, получаем также $R$, кладем его в $M_{0}$. Пытаясь продолжить эти вычисления в данном потоке, мы обнаружим, что при переходе по $a$ из вершины 0 в вершину 1 наша производная будет снова R, но в множестве $M_{1}$ $R$ уже находится, а значит, данная ветка вычислений терминируется.
        \item При переходе по $b$ диффиринцируем переданную производную $R$: $\partial_{b}(R) = \partial_{b}(a^* \mid a^* \cdot b) = \partial_{b}(a^*) \mid \partial_{b}(a^* \cdot b) = \partial_{b}(a) \cdot a^* \mid \partial_{b}(a^*) \cdot b \mid \partial_{b}(b) = \partial_{b}(b) = \varepsilon$. Запоминаем производную в $M_{3}$:  $M_{3} = \{\varepsilon\}$. Дифференцируем её по $b$ при переходе из 3 в 2. Кладём в $M_{2}$ $\partial_{b}(\varepsilon) = \emptyset$. Tаким oбразом, $M_{2} = \{R, \emptyset\}$. На данном этапе можно терминирироваться, т.к. для достижимости нам интересны регулярные выражения, порождающий $\varepsilon$, но дифференцируя $\emptyset$ по каким-либо меткам, мы снова получаем $\emptyset$. При "честном" вычислении, в нашем случае пустое множество будет добавлено во все множества $M_{i}$, и уже после этого вычисление завершится.    
    \end{enumerate}
    \item Теперь у нас есть сформированные множества производных для всех вершин и мы можем говорить о достижимости до данных вершин из стартовой. Рассмотрим $M_{0}$, $M_{0} = \{R\}$. Содержит ли $R$ $\varepsilon$? Посчитаем для этого нашу функцию Nullable: $N(R) = N(a^* \mid a^* \cdot b) = N(a^*) \mid N(a^* \cdot b) = true \mid N(a^* \cdot b) = true$. Из чего следует, что существует путь из вершины 0 в вершину 0. Аналогичным способом заключаем, что веришны 2 и 3 достижимы из вершины 0 (т.к. в их множества также содержится $R$). Рассмотрим $M_{3} = \{\varepsilon\}$. $N(\varepsilon) = true$, значит, вершина  3 тоже достижима из 0. Алгоритм завершён.
\end{enumerate}

Таким образом, выполнив указанный выше алгоритм для данного примера, мы определили, что из стартовой вершины с индексом 0 достижимы все вершины графа $\mathcal{G}$.
\end{example}

\section{Парсинг на производных}

Статьи~\cite{DBLP:journals/corr/abs-1010-5023,Adams:2016:CPP:2908080.2908128,Might:2011:PDF:2034574.2034801,andersenparsing}
Реализации.
На Scala~\footnote{\url{https://github.com/djspiewak/parseback}}, на Racket~\footnote{\url{https://bitbucket.org/ucombinator/derp-3/src/86bca8a720231e010a3ad6aefd1aa1c0f35cbf6b/src/derp.rkt?at=master&fileviewer=file-view-default}}.

\section{Адаптация для КС запросов}

Для регулярных запросов над графами~\cite{Nole:2016:RPQ:2949689.2949711}.
Хорошо работают в распределённых системах, в которых реализовван параллелизм уровня вершин. 
Например Google Pregel.



\section{Вопросы и задачи}
\begin{enumerate}
  \item Предъявить несколько выводов для одной цепочки.
  \item Построить выводы
  \item Построить деревья вывода !!! Перенести из раздела про SPPF
\end{enumerate}

