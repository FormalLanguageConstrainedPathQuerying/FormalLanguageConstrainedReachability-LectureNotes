\chapter[Некоторые понятия линейной алгебры]{Некоторые понятия линейной алгебры\footnote{Неообходимо понимать, что, с одной строны, в данном разделе рассматриваются самые базовые понятия, которые даются практически в любом учебнике алгебры. С другой же стороны, определения данных понятий оказываются весьма вариативными и часто вызывают дискуссии. Напрмиер, интересный анализ тонкостей определения группы можно найти в первом и втором параграфах первого раздела книги Николая Александровича Вавилова ``Конкретная теория групп''~\cite{VavilovGroups}. Мы же дадим определения, удобные для дальнейшего изложения материала.}}\label{chpt:LinAlIntro}

При изложении ряда алгоритмов будут активно использоваться некоторые понятия и инструменты линейной алгебры, такие как моноид, полукольцо или матрица.
В данном разделе необходимые понятия будут определены и приведены некоторые примеры соответствующих конструкций. Для более глубокого изучения материала рекомендуются обратиться к соответствующим разделам алгебры.


\section{Бинарные операции и их свойства}


Введём понятие \textit{бинарной операции} и рассмотрим некоторые её свойства, такие как \textit{коммутативность} и \textit{ассоциативность}.

\begin{definition}
	Функцию, принимающую два аргумента, $f: S \times K \to Q$ будем называть \emph{двухместной} или \emph{функцией арности два}.
Для записи таких функций будем использовать типичную нотацию: $c = f(a,b)$.
\end{definition}


\begin{definition}
\emph{Бинарная операция} --- это двухместная функция, от которой дополнительно требуется, чтобы оба аргумента и результат лежали в одном и том же множестве: $f: S \times S \to S$. В таком случае говорят, что бинарная операция определена на некотором множестве $S$. Для обозначения произвольной бинарной операции будем использовать символ $\circ$ и пользоваться инфиксной нотацией для записи: $c = a \circ b$.
\end{definition}




\begin{definition}
\emph{Внешняя бинарная операция} --- это бинарная операция, у которой аргументы лежат в разных множествах, при этом результат --- в одном из этих множеств. Иными словами $\circ: K \times S \to S$, где $K$ может не совпадать с $S$  --- внешняя бинарная операция.
\end{definition}


Необходимо помнить, что как функции, так и бинарные операции, могут быть частично определёнными (частичные функции, частичные бинарные операции). Типичным примером частично определённой бинарной операции является деление на целых числах: она не определена, если второй аргумент равен нулю.


Бинарные операции могут обладать некоторыми дополнительными свойствами, такими как \textit{коммутативность} или \textit{ассоциативность}, позволяющими преобразовывать выражения, составленные с использованием этих операций.


\begin{definition}
Бинарная операция $\circ : S \times S \to S$ называется \emph{коммутативной}, если для любых  $x_1 \in S, x_2 \in S$ верно, что  $x_1 \circ x_2 = x_2 \circ x_1$.
\end{definition}

\begin{example} Рассмотрим несколько примеров коммутативных и некоммутативных операций.
	\begin{itemize}
		\item Операция сложения на целых числах $+$ является коммутативной: известный ещё со школы перестановочный закон сложения.
		\item Операция конкатенации на строках $+$ не является коммутативной: $$``ab" + ``c" \ = ``abc" \neq ``c" + ``ab" \ = ``cab".$$
		\item Операция умножения на целых числах является коммутативной: известный ещё со школы перестановочный закон умножения.
		\item Операция умножения матриц (над целыми числами) $\cdot$ не является коммутативной:
		$$\begin{pmatrix}
		1 & 1 \\ 0 & 0
		\end{pmatrix}
		\cdot
		\begin{pmatrix}
		0 & 0 \\ 1 & 1
		\end{pmatrix}
		=
		\begin{pmatrix}
		1 & 1 \\ 0 & 0
		\end{pmatrix}
		\neq
		\begin{pmatrix}
		0 & 0 \\ 1 & 1
		\end{pmatrix}
		\cdot
		\begin{pmatrix}
		1 & 1 \\ 0 & 0
		\end{pmatrix}
		=
		\begin{pmatrix}
		0 & 0 \\ 1 & 1
		\end{pmatrix}
		.$$
	\end{itemize}
\end{example}

\begin{definition}
Бинарная операция $\circ : S \times S \to S$ называется \emph{ассоциативной}, если для любых  $x_1 \in S, x_2 \in S, x_3 \in S$ верно, что  $(x_1 \circ x_2) \circ x_3 = x_1 \circ (x_2 \circ x_3)$. Иными словами, для ассоциативной операции результат вычислений не зависит от порядка применения операций.
\end{definition}

\begin{example} Рассмотрим несколько примеров ассоциативных и неассоциативных операций.
	\begin{itemize}
		\item Операция сложения на целых числах $+$ является ассоциативной.
		\item Операция умножения на целых числах является ассоциативной.
		\item Операция конкатенации на строках $+$ является ассоциативной: $$(``a" + ``b") + ``c" \ = ``a" + (``b" + ``c") = ``abc" .$$
		\item Операция возведения в степень (над целыми числами) $\hat{\mkern6mu}$ не является ассоциативной:
		$$(2\hat{\mkern6mu}2)\hat{\mkern6mu}3 = 4 \hat{\mkern6mu} 3 = 64 \neq 2\hat{\mkern6mu}(2\hat{\mkern6mu}3) = 2 \hat{\mkern6mu} 8  = 256.$$
	\end{itemize}
\end{example}


\begin{definition}
Говорят, что бинарная операция $\otimes : S \times S \to S$ является \emph{дистрибутивной} относительно бинарной операции $\oplus : S \times S \to S$, если
\begin{enumerate}
	\item Для любых $x_1,x_2,x_3 \in S, x_1 \otimes (x_2 \oplus x_3) = (x_1 \otimes x_2) \oplus (x_1 \otimes x_3)$ (дистрибутивность слева).
	\item Для любых $x_1,x_2,x_3 \in S, (x_2 \oplus x_3) \otimes x_1 = (x_2 \otimes x_1) \oplus (x_3 \otimes x_1)$ (дистрибутивность справа).
\end{enumerate}

Если операция $\otimes$ является коммутативной, то дистрибутивность слева и справа равносильны.

\end{definition}

\begin{example} Рассмотрим несколько примеров дистрибутивных операций.

\begin{itemize}
	\item Умножение целых чисел дистрибутивно относительно сложения и вычитания: классический \textit{распределительный закон}, знакомый всем со школы.
	\item Операция деления (допустим, на действительных числах) не коммутативна. при этом, она дистрибутивна справа относительно сложения и вычитания, но не дистрибутивна слева.
	$$(a + b) / c = (a / c) + (b / c) $$
	но
	$$c / (a + b) \neq (c / a) + (c / b)\footnote{Здесь может быть уместно вспомнить правила сложения дробей. Дроби с общим знаминателем складывать проще как раз из-за дистрибутивности справа.}.$$
\end{itemize}

\end{example}

\begin{definition}
Бинарная операция $\circ : S \times S \to S$ называется \emph{идемпотентной}, если для любого  $x \in S$ верно, что  $x \circ x = x$.
\end{definition}



\begin{example} Рассмотрим несколько примеров идемпотентных операций.

\begin{itemize}
	\item Операция объединения множеств $\cup$ является идемпотентной: для любого множества $S$ верно, что $S \cup S = S$.
	\item Операция сложения на целых числах не является идемпотентной.
	\item Операции ``логическое и'' $\wedge$ и ``логическое или'' $\vee$ являются идемпотентными.
	\item Операция ``исключающее или'' не является идемпотентной.
\end{itemize}

\end{example}

\begin{definition}
Пусть есть коммутативная бинарная операция $\circ$ на множестве $S$. Говорят, что $x\in S$ является \emph{нейтральным элементом} по операции $\circ$, если для любого $y\in S$ верно, что $x \circ y = y \circ x = y$. Если бинарная операция не является коммутативной, то можно определить \textit{нейтральный слева} и \textit{нейтральный справа} элементы по аналогии.
\end{definition}


\section{Полугруппа}


\begin{definition}
Множество с заданной на нём ассоциативной бинарной операцией $(S,\cdot : S \times S \to S )$ называется \emph{полугруппой}.
Если операция $\cdot$ является коммутативной, то говорят о \textit{коммутативной полугруппе}.
\end{definition}


\begin{example} Приведём несколько примеров полугрупп.
\begin{itemize}
	\item Положительные целые числа с операцией сложения являются полугруппой. Более того, коммутативной полугруппой.
	\item Целые числа с операцией взятия наибольшего из двух ($\max$) являются полугруппой. Более того, коммутативной полугруппой.
	\item Множество всех строк конечной длины (без пустой строки) над фиксированным алфавитом $\Sigma$ с операцией конкатенации является полугруппой. Так как конкатенация на строках не является коммутативной операцией, то и полугруппа не является коммутативной.
\end{itemize}
\end{example}


\section{Моноид}


\begin{definition}
	\emph{Моноидом} называется полугруппа с нейтральным элементом. Если операция является коммутативной, то можно говорить о коммутативном моноиде.
\end{definition}

\begin{example} Приведём примеры моноидов, построенных на основе полугрупп из предыдущего раздела.

\begin{itemize}
	\item Неотрицательные целые числа с операцией сложения являются моноидом. Нейтральный элемент --- $0$.
	\item Целые числа, дополненные значением $-\infty$ (``минус-бесконечность'') с операцией взятия наибольшего из двух ($\max$) являются моноидом. Нейтральный элемент --- $-\infty$.
	\item Множество всех строк конечной длины с пустой строкой (строка длины 0) над фиксированным алфавитом $\Sigma$ и операцией конкатенации является моноидом. Нейтральный элемент --- пустая строка.
	\item Квадратные неотрицательные матрицы\footnote{Неотрицательной называется матрица, все элементы которой не меньше нуля.} фиксированного размера с операцией умножения задают моноид. Нейтральный элемент --- единичная матрица.
\end{itemize}
\end{example}


\section{Группа}

\begin{definition}
Непустое\footnote{Требование непустоты здесь, как и далее, в определениях полукольца и кольца --- дискуссионный вопрос.} множество $G$ с заданной на нём бинарной операцией $\circ: {G} \times {G} \to {G}$ называется \emph{группой} $(G ,\circ)$, если выполнены следующие аксиомы:
\begin{enumerate}
\item ассоциативность: $\forall (a,b,c\in G)\colon (a\circ b)\circ c = a\circ (b \circ c)$;
\item наличие нейтрального элемента: $ \exists e \in G \quad \forall a\in G\colon (e \circ a = a \circ e = a)$;
\item наличие обратного элемента: $ \forall a\in G\quad \exists a^{-1}\in G\colon (a \circ a^{-1}=a^{-1} \circ a = e)$.
\end{enumerate}

Иными словами, группа --- это моноид с дополнительным требованием наличия обратных элементов.
\end{definition}

\begin{definition}
Если операция $\circ$ коммутативна, то говорят, что группа \textit{Абелева}.
\end{definition}


\section{Полукольцо}

\begin{definition}

Непустое множество $R$ с двумя бинарными операциями $\oplus\colon R \times R \to R$ (часто называют умножением) и $\otimes \colon R \times R \to R$ (часто называют сложением) называется \emph{полукольцом}, если выполнены следующие условия.
\begin{enumerate}

\item $(R, \oplus)$ --- это коммутативный моноид, нейтральный элемент которого --- $\mathbb{0}$. Для любых $a,b,c \in R$:
\begin{itemize}
	\item $(a \oplus b) \oplus c = a \oplus (b \oplus c)$
	\item $\mathbb{0} \oplus a = a \oplus \mathbb{0} = a$
	\item $a \oplus b = b \oplus a$
\end{itemize}

\item $(R, \otimes)$ --- это моноид, нейтральный элемент которого --- $\mathbb{1}$. Для любых $a,b,c \in R$:
\begin{itemize}
	\item $(a \otimes b) \otimes c = a \otimes (b \otimes c)$
    \item $\mathbb{1} \otimes a = a \otimes \mathbb{1} = a$
\end{itemize}

\item $\otimes$ дистрибутивно слева и справа относительно $\oplus$:
\begin{itemize}
	\item $a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c)$
    \item $(a \oplus b) \otimes c = (a \otimes c) \oplus (b \otimes c)$
\end{itemize}


\item $\mathbb{0}$ является \textit{аннигилятором} по умножению: для любого $a \in R$
$\mathbb{0} \otimes a = a \otimes 0 = 0$

\end{enumerate}

Если операция $\otimes$ коммутативна, то говорят о коммутативном полукольце.
Если операция $\oplus$ идемпотентна, то говорят об идемпотентном полукольце.

\end{definition}

\begin{example}\label{exmpl:semiring}
Рассмотрим пример полукольца, а заодно покажем, что левая и правая дистрибутивность могут существовать независимо для некоммутативного умножения\footnote{Хороший пример того, почему левую и правую дистрибутивность в случае некоммутативного умножения нужно проверять независимо (правда, для колец), приведён Николаем Александровичем Вавиловым в книге ``Конкретная теория колец'' на странице 6~\cite{VavilovRings}.}.

В качестве $R$ возьмём множество множеств строк конечной длины над некоторым алфавитом $\Sigma$. В качестве сложения возьмём теоретико-множественное объединение: $\oplus  \equiv \cup$. Нейтральный элемент по сложению --- это пустое множество ($\varnothing$).
В качестве умножения возьмём конкатенацию множеств ($\otimes  \equiv \odot$) и оперделим её следующим образом:
$$ S_1 \odot S_2 = \{ w_1 \cdot w_2 \mid w_1 \in S_1, w_2 \in S_2\}$$, где $\cdot$ --- конкатенация строк. Нейтральным элементом по умножению будет являться множество из пустой строки: $\{\varepsilon\}$, где $\varepsilon$ --- обозначение для пустой строки.

Проверим, что $(R, \cup, \odot)$ действительно полукольцо по нашему определению.

\begin{enumerate}

\item $(R, \cup)$ --- действительно коммутативный моноид с нейтральным элементом $\varnothing$. Для любых $a,b,c \in R$ по свойствам теоретико-множественного объединения верно:
\begin{itemize}
	\item $(a \cup b) \cup c = a \cup (b \cup c)$
	\item $\varnothing \cup a = a \cup \varnothing = a$
	\item $a \cup b = b \cup a$.
\end{itemize}

\item $(R, \odot)$ --- действительно моноид с нейтральным элементом $\{\varepsilon\}$. Для любых $a,b,c \in R$:
\begin{itemize}
	\item $(a \odot b) \odot c = a \odot (b \odot c)$ по определению $\odot$
    \item $\{\varepsilon\} \odot a = \{\varepsilon \cdot w \mid w \in a \} = \{w \mid w \in a \} = a \odot \{\varepsilon\} = a$
\end{itemize}
Вообще говоря, сконструированный нами моноид не является коммутативным: легко проверить, например, что для любых непустых $a,b \in R, a \neq b, a \neq \{\varepsilon\}, b \neq \{\varepsilon\}$: $a \cdot b \neq b \cdot a$ по причине некоммутативности конкатенации строк.

\item $\odot$ дистрибутивно слева и справа относительно $\cup$:
\begin{itemize}
	\item $a \odot (b \cup c) = \{ w_1 \cdot w_2 \mid  w_1 \in a, w_2 \in b \cup c\} = \{ w_1 \cdot w_2 \mid  w_1 \in a, w_2 \in b \} \cup  \{ w_1 \cdot w_2 \mid  w_1 \in a, w_2 \in c \} =  (a \odot b) \cup (a \odot c)$
    \item Аналогично, $(a \cup b) \odot c = (a \odot c) \cup (b \odot c)$
\end{itemize}
При этом, в общем случае, $a \odot (b \cup c) \neq (a \cup b) \odot c$.


\item $\varnothing$ является \textit{аннигилятором} по умножению: для любого $a \in R$ верно, что
$\varnothing \odot a =  \{ w_1 \cdot w_2 \mid w_1 \in \varnothing, w_2 \in a \} =  \{ w_1 \cdot w_2 \mid w_1 \in a, w_2 \in \varnothing \} = a \odot \varnothing = \varnothing$

\end{enumerate}

\end{example}

\section{Кольцо}


\begin{definition}

Непустое множество $R$ с двумя бинарными операциями $\oplus\colon R \times R \to R$ (умножение) и $\otimes \colon R \times R \to R$ (сложение) называется \emph{кольцом}, если выполнены следующие условия.
\begin{enumerate}

\item $(R, \oplus)$ --- это Абелева группа, нейтральный элемент которой --- $\mathbb{0}$. Для любых $a,b,c \in R$:
\begin{itemize}
	\item $(a \oplus b) \oplus c = a \oplus (b \oplus c)$
	\item $\mathbb{0} \oplus a = a \oplus \mathbb{0} = a$
	\item $a \oplus b = b \oplus a$
	\item для любого $a \in R$ существует $-a \in  R$, такое что $a + (-a) = \mathbb{0}$.
\end{itemize}
В последнем пункте кроется отличие от полукольца.

\item $(R, \otimes)$ --- это моноид, нейтральный элемент которого --- $\mathbb{1}$. Для любых $a,b,c \in R$:
\begin{itemize}
	\item $(a \otimes b) \otimes c = a \otimes (b \otimes c)$
    \item $\mathbb{1} \otimes a = a \otimes \mathbb{1} = a$
\end{itemize}

\item $\otimes$ дистрибутивно слева и справа относительно $\oplus$:
\begin{itemize}
	\item $a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c)$
    \item $(a \oplus b) \otimes c = (a \otimes c) \oplus (b \otimes c)$
\end{itemize}

\end{enumerate}

Заметим, что мультипликативное свойство $\mathbb{0}$ (быть аннигилятором по умножению) не указыватеся явно, так как может быть выведено из остальных утверждений.

\end{definition}


%\section{Поле}

\section{Матрицы и вектора}

К определению матрицы мы подойдём структурно, так как в дальнейшем будем сопоставлять эту структуру с объектами различной природы, а значит определение матрицы через какой-либо из этих объектов (например через квадратичные формы) будет менее удобным.

Договоримся, что \textit{алгебраическая структура} --- это собирательное название для объектов вида ``множество с набором операций'' (например, кольцо, моноид, группа и т.д.), а соответствующее множество будем назвать \textit{носителем} этой структуры.

\begin{definition}

Предположим, что у нас есть некоторая алгебраическая структура с носителем $S$. Тогда \emph{матрицей} будем называть прямоугольный массив размера $n\times m, n > 0, m > 0$, заполненный элементами из $S$.

Говорят, что $n$ --- это высота матрицы или количество строк в ней, а $m$ --- ширина матрицы или количество столбцов.

\end{definition}

При доступе к элементам матрицы используются их индексы. При этом нумерация ведётся с левого верхнего угла, первым указывается строка, вторым --- столбец. В нашей работе мы будем использовать ``программистскую'' традицию и нумеровать строки и столбцы с нуля\footnote{В противоположность ``математической'' традиции нумеровать строки и столбцы с единицы. Стоит, правда, отметить, что в некоторых языках программирования (например, Fortran или COBOL) жива ``математическая'' традиция.}.

\begin{example}[Матрица]

Пусть есть моноид $(S,\cdot)$, где $S$ --- множества строк конечной длины над алфавитом \{a,b,c\}.
Тогда можно построить, например, следующую матрицу $2\times 3$.
$$
M_{2\times 3} =
\begin{pmatrix}
``a" & ``ba" & ``cb" \\
``ac" & ``bab" & ``b" \\
\end{pmatrix}
$$

$$
M_{2\times 3}[1,1] = ``bab"
$$

\end{example}

К определению вектора мы также подойдём структурно.

\begin{definition}

\emph{Вектором} будем называть матрицу, хотя бы один из размеров которой равен единице. Если единице равна высота матрицы, то это \textit{вектор-строка}, если же единице равна ширина матрицы, то это \textit{вектор-столбец}.

\end{definition}


Операции над матрицами можно условно разделить на две группы:
\begin{itemize}
	\item \textit{структурные} --- не зависящие от алгебраической структуры, над которой строилась матрица, и работающие только с её структурой;
	\item \textit{алгебраические} --- определение таковых опирается на свойства алгебраической структуры, над которой построена матрица.
\end{itemize}

Примерами структурных операций является \textit{транспонирование}, \textit{взятие подматрицы} и \textit{взятие элемента по индексу}.

\begin{definition}[Транспонирование матрицы]
Пусть дана матрица $M_{n\times m}$. Тогда результат её \emph{транспонирования}
$
M_{n\times m}^T = M'_{m\times n},
$
такая что $M'[i,j] = M[j,i]$ для всех $0\leq i \leq m - 1$ и $0\leq j \leq n - 1$.
\end{definition}

\begin{example}
$$
\begin{pmatrix}
``a"  & ``ba"  & ``cb" \\
``ac" & ``bab" & ``b"  \\
\end{pmatrix}^T =
\begin{pmatrix}
``a"  & ``ac"  \\
``ba" & ``bab" \\
``cd" & ``b" \\
\end{pmatrix}
$$
\end{example}

\begin{definition}[Взятие подматрицы]
Пусть дана матрица $M_{n\times m}$. Тогда
$
M_{n\times m}[i_0..i_1,j_0..j_1]
$
 --- это такая $M'_{i_1 - i_0 + 1, j_1 - j_0 + 1}$ что $M'[i,j] = M[i_0 + i,j_0 + j]$ для всех $0\leq i \leq i_1 - i_0 + 1$ и $0\leq j \leq j_1 - j_0 + 1$.
\end{definition}


\begin{example}
$$
\begin{pmatrix}
``a"  & ``ba"  & ``cb" \\
``ac" & ``bab" & ``b"  \\
\end{pmatrix}[0..1,1..2] =
\begin{pmatrix}
``ba"  & ``cb" \\
``bab" & ``b"  \\
\end{pmatrix}
$$
\end{example}


\begin{definition}
\emph{Взятие элемента по индексу} --- это частный случай взятия подматрицы, когда начало и конец ``среза'' совпадают:
$
M[i,j] = M[i..i,j..j]
$
\end{definition}

\begin{example}
$$
\begin{pmatrix}
``a"  & ``ba"  & ``cb" \\
``ac" & ``bab" & ``b"  \\
\end{pmatrix}[0,1] = ``ba"
$$
\end{example}

Из алгебраических операций над матрицами нас в дальнейшем будут интересовать \textit{поэлементные операции}, \textit{скалярные операции}, \textit{матричное умножение}, \textit{произведение Кронекера}.


\begin{definition}[Поэлементные операции]

Пусть $G = (S,\circ)$ --- полугруппа, $M_{n \times m}, N_{n\times m}$ --- две матрицы одинакового размера над этой полугруппой.
Тогда
$
ewise(M,N,\circ) = P_{n \times m}
$
,такая, что $P[i,j] = M[i,j] \circ N[i,j]$.
\end{definition}


\begin{example}

Пусть $G$ --- полугруппа строк с конкатенацией $\cdot$,

$$
M =
\begin{pmatrix}
``a"  & ``ba"  & ``cb" \\
``ac" & ``bab" & ``b"  \\
\end{pmatrix},
$$

$$
N =
\begin{pmatrix}
``c"  & ``aa"  & ``b" \\
``a" & ``bac" & ``bb"  \\
\end{pmatrix}.
$$

Тогда

$$
ewise(M,N, \cdot) =
\begin{pmatrix}
``ac"  & ``baaa"  & ``cbb" \\
``aca" & ``babbac" & ``bbb"  \\
\end{pmatrix}.
$$


\end{example}


\begin{definition}[Скалярная операция]
Пусть $G = (S,\circ)$ --- полугруппа, $M_{n \times m}$ --- матрица над этой полугруппой, $x \in S$.
Тогда
$
scalar(M,x,\circ) = P_{n \times m}
$
, такая, что $P[i,j] = M[i,j] \circ x$, а
$
scalar(x,M,\circ) = P_{n \times m}
$
, такая, что $P[i,j] = x \circ M[i,j]$.

\end{definition}

\begin{example}

Пусть $G$ --- полугруппа строк с конкатенацией $\cdot$, $x = ``c"$,

$$
M =
\begin{pmatrix}
``a"  & ``ba"  & ``cb" \\
``ac" & ``bab" & ``b"  \\
\end{pmatrix}.
$$

Тогда
$$
scalar(M,x, \cdot) =
\begin{pmatrix}
``ac"  & ``bac"  & ``cbc" \\
``acc" & ``babc" & ``bc"  \\
\end{pmatrix},
$$

$$
scalar(x, M, \cdot) =
\begin{pmatrix}
``ca"  & ``cba"  & ``ccb" \\
``cac" & ``cbab" & ``cb"  \\
\end{pmatrix}.
$$

\end{example}


\begin{definition}[Матричное умножение]\label{def:MxM}

Пусть $G = (S,\oplus, \otimes)$ --- полукольцо, $M_{n \times m}, N_{m\times k}$ --- две матрицы над этим полукольцом.
Тогда
$
M\cdot N = P_{n \times k}
$
, такая, что $P[i,j] = \bigoplus_{0 \leq l < m} M[i,l] \otimes N[l,j]$.

\end{definition}

\begin{example}
Пусть $G$ --- полукольцо из примера~\ref{exmpl:semiring},
$$ M =
\begin{pmatrix}
\{``a"\} & \{``a"\}\\
\{``b"\} & \{``b"\}\\
\end{pmatrix},
$$
$$ N =
\begin{pmatrix}
\{``c"\} \\
\{``d"\} \\
\end{pmatrix}.
$$

Тогда
$$
M \cdot N =
\begin{pmatrix}
\{``a" \cdot ``c"\} \cup \{``a" \cdot ``d"\} \\
\{``b" \cdot ``c"\} \cup \{``b" \cdot ``d"\}
\end{pmatrix}=
\begin{pmatrix}
\{``ac" \ ,  ``ad"\} \\
\{``bc" \ , ``bd"\}
\end{pmatrix}.
$$

\end{example}


\begin{definition}[Произведение Кронекера]
Пусть $G = (S,\circ)$ --- полугруппа, $M_{m\times n}$ и $N_{p\times q}$ --- две матрицы над этой полугруппой.
Тогда произведение Кронекера или тензорное произведение матриц $M$ и $N$ --- это блочная матрица $C$ размера $mp \times nq$, вычисляемая следующим образом:
$$
C = A \otimes B =
\begin{pmatrix}
scalar(M[0,0],N,\circ)   & \cdots & scalar(M[0,n-1],N,\circ)   \\
\vdots                   & \ddots & \vdots       \\
scalar(M[m-1,0],N,\circ) & \cdots & scalar(M[m-1,n-1],N,\circ)
\end{pmatrix}
$$

\end{definition}

\begin{note}\label{note:KronIsNotCommutative}
Отметим, что произведение Кронекера не является коммутативным.
При этом всегда существуют две матрицы перестоновок $P$ и $Q$ такие, что $A \otimes B = P(B \otimes A)Q$.
Это свойство потребуется нам в дальнейшем.
\end{note}

\newcommand{\examplemtrx}
{
\begin{pmatrix}
5 & 6 & 7 & 8 \\
9 & 10 & 11 & 12 \\
13 & 14 & 15 & 16
\end{pmatrix}
}

\begin{example}
Возьмём в качестве полугруппы целые числа с умножением.
$$M=
\begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}
$$
$$N=\examplemtrx
$$
Тогда
\begin{align}
M \otimes N & =
\begin{pmatrix}
1 & 2 \\
3 & 4
\end{pmatrix}
\otimes
\examplemtrx = \notag \\ &=
\begin{pmatrix}
1\examplemtrx & 2\examplemtrx \\
3\examplemtrx & 4\examplemtrx
\end{pmatrix}
=\notag \\
&=
\left(\begin{array}{c c c c | c c c c}
5  & 6  & 7  & 8  & 10 & 12 & 14 & 16 \\
9  & 10 & 11 & 12 & 18 & 20 & 22 & 24 \\
13 & 14 & 15 & 16 & 26 & 28 & 30 & 32 \\
\hline
15 & 18 & 21 & 24 & 20 & 24 & 28 & 32 \\
27 & 30 & 33 & 36 & 36 & 40 & 44 & 48 \\
39 & 42 & 45 & 48 & 52 & 56 & 60 & 64
\end{array}\right)
\end{align}
\end{example}


\section{Теоретическая сложность умножения матриц}

В рамках такого раздела теории сложности, как мелкозернистая сложность (fine-grained complexity) задача умножения двух матриц оказалась достаточно важной, так как через вычислительную сложность этой задачи можно оценить сложность большого класса различных задач. С примерами таких задач можно ознакомиться в работе~\cite{Williams:2010:SEP:1917827.1918339}. Поэтому рассмотрим алгоритмы нахождения произведения двух матриц более подробно. Далее для простоты мы будем предполагать, что перемножаются две квадратные матрицы одинакового размера $n \times n$.

Для начал построим наивный алгоритм, сконструированный на основе определении произведения матриц. Такой алгоритм представлен на листинге~\ref{algo:MxM}. Его работу можно описать следующим образом: для каждой строки в первой матрице и для каждого столбца в второй матрице найти сумму произведений соответствующих элементов. Данная сумма будет значением соответствующей ячейки результирующей матрицы.

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]\label{algo:MxM}
\caption{Наивное перемножение матриц}
\Function{MatrixMult}{$M_1, M_2, G=(S,\oplus,\otimes)$}
    \State{$M_3 =$ empty matrix of size $n \times n$}
    \For {$i \in 0..n-1$}
    \For {$j \in 0..n-1$}
    \For {$k \in 0..n-1$}
     \State{$M_3[i,j] = M_3[i,j] \oplus ( M_1[i,k] \otimes M_2[k,j])$}
    \EndFor
    \EndFor
    \EndFor
    \State{\Return $M_3$}

\EndFunction
\end{algorithmic}
\end{algorithm}

Сложность наивного произведения двух матриц составляет $O(n^3)$, что очевидным образом следует из псевдокода. Но можно ли улучшить этот алгоритм? Первый положительный ответ был опубликовал Ф. Штрассен в 1969 году~\cite{Strassen1969}. Сложность предложенного им алгоритма --- $O(n^{\log_2 7}) \approx O(n^{2.81})$. Основная идея --- рекурсивное разбиение исходных матриц на блоки и вычисление их произведения с помощью только 7 умножений, а не 8.

Рассмотрим алгоритм Штрассена более подробно. Пусть $A$ и $B$ --- две квадратные матрицы размера $2^n \times 2^n$\footnote{Если размер умножаемых матриц не является натуральной степенью двойки, мы дополняем исходные матрицы дополнительными нулевыми строками и столбцами.} над кольцом $R=(S,\oplus,\otimes)$. Наша задача найти матрицу $C = A \cdot B$.

Разделим матрицы $A, B$ и $C$ на четыре равные по размеру блока.
$$
A =
\begin{pmatrix}
  A_{1,1} & A_{1,2} \\
  A_{2,1} & A_{2,2}
 \end{pmatrix} \mbox{ , }
 B =
 \begin{pmatrix}
   B_{1,1} & B_{1,2} \\
   B_{2,1} & B_{2,2}
 \end{pmatrix} \mbox{ , }
 C =
 \begin{pmatrix}
   C_{1,1} & C_{1,2} \\
   C_{2,1} & C_{2,2}
 \end{pmatrix}
$$

На основе определения произведения матриц легко убедиться, что выполняются следующие равенства.
\begin {align*}
C_{1,1}&= A_{1,1} \cdot B_{1,1} + A_{1,2} \cdot B_{2,1} \\
C_{1,2}&= A_{1,1} \cdot B_{1,2} + A_{1,2} \cdot B_{2,2} \\
C_{2,1}&= A_{2,1} \cdot B_{1,1} + A_{2,2} \cdot B_{2,1} \\
C_{2,2}&= A_{2,1} \cdot B_{1,2} + A_{2,2} \cdot B_{2,2}
\end {align*}

Данная процедура не даёт нам ничего нового с точки зрения вычислительной сложности. Но мы можем двинуться дальше и определить следующие элементы.

\begin {align*}
P_1 & \equiv (A_{1,1} + A_{2,2}) \cdot (B_{1,1} + B_{2,2}) \\
P_2 & \equiv (A_{2,1} + A_{2,2}) \cdot B_{1,1} \\
P_3 & \equiv A_{1,1} \cdot (B_{1,2} - B_{2,2}) \\
P_4 & \equiv A_{2,2} \cdot (B_{2,1} - B_{1,1}) \\
P_5 & \equiv (A_{1,1} + A_{1,2}) \cdot B_{2,2}  \\
P_6 & \equiv (A_{2,1} - A_{1,1}) \cdot (B_{1,1} + B_{1,2}) \\
P_7 & \equiv (A_{1,2} - A_{2,2}) \cdot (B_{2,1} + B_{2,2})
\end {align*}

Используя эти элементы мы можем выразить блоки результирующей матрицы следующим образом.

\begin {align*}
C_{1,1} & = P_1 + P_4 - P_5 + P_7 \\
C_{1,2} & = P_3 + P_5 \\
C_{2,1} & = P_2 + P_4 \\
C_{2,2} & = P_1 - P_2 + P_3 + P_6
\end {align*}

При таком способе вычисления мы получаем на одно умножение подматриц меньше, чем при наивном подходе. Это и приводит, в конечном итоге, к улучшению сложности всего алгоритма, который основывается на рекурсивном повторении проделанной выше процедуры.

Впоследствии сложность постепенно понижалась в ряде работ, таких как ~\cite{Pan1978,BiniCapoRoma1979,Schonhage1981,CoppWino1982,CoppWino1990}. Было введено специальное обозначение для показателя степени в данной оценке: $\omega$. То есть сложность умножения матриц --- это $O(n^\omega)$, и задача сводится к уменьшению значения $\omega$. В настоящее время работа над уменьшением показателя степени продолжается и сейчас уже предложены решения с $\omega < 2.373$\footnote{В данной области достаточно регулярно появляются новые результаты, дающие сравнительно небольшие, в терминах абсолютных величин, изменения. Так, в 2021 была представлена работа, улучшающая значение $\omega$ в пятом знаке после запятой~\cite{alman2020refined}. Несмотря на кажущуюся несерьёзность результата, подобные работы имеют большое теоретическое значение, так как улучшают наше понимание исходной задачи и её свойств.}.

Всё тем же Ф. Штрассеном ещё в 1969 году была выдвинута гипотеза о том, что для достаточно больших $n$ существует алгоритм, который для любого сколь угодно маленького наперёд заданного $\varepsilon$ перемножает матрицы за $O(n^{2+\varepsilon})$. На текущий момент ни доказательства, ни опровержения этой гипотезы не предъявлено.

Важной особенностью указанного выше направления улучшения алгоритмов является то, что оно допускает использования (и даже основывается на использовании) более богатых алгебраических структур, чем требуется для определения умножения двух матриц. Так, уже алгоритм Штрасеена использует операцию вычитания, что приводит к необходимости иметь обратные элементы по сложению, а значит определять матрицы над кольцом. Хотя для исходного определения (\ref{def:MxM}) достаточно более бедной структуры. При этом, часто, структуры, возникающие в прикладных задачах кольцами не являются. Примерами могут служить тропическое (или $\{min,+\}$) полукольцо, играющее ключевую роль в тропической математике, или булево ($\{\vee,\wedge\}$) полукольцо, возникающее, например, при работе с отношениями\footnote{Вообще говоря, в некоторых прикладных задачах возникают структуры, не являющиеся даже полукольцом. Предположим, что есть три различных множества $S_1, S_2$ и $S_3$ и две двухместные функции $f:S_1 \times S_2 \to S_3$ и $g: S_3 \times S_3 \to S_3$. Этого достаточно, чтобы определить произведение двух матриц $M_1$ и $M_2$, построенных из элементов множеств $S_1$ и $S_2$ соответственно. Результирующая матрица будет состоять из элементов $S_3$. Как видно, функции не являются бинарными операциями в смысле нашего определения. Несмотря на кажущуюся экзотичность, подобные структуры возникают на практике при работе с графами и учитываются, например, в стандарте GraphBLAS (\url{https://graphblas.github.io/}), где, кстати, называются полукольцами, что выглядит не вполне корректно.}. Значит, описанные выше решения не применимы и вопрос о существовании алгоритма с менее чем кубической сложностью снова актуален.

В попытках ответить на этот вопрос появились так называемые комбинаторные алгоритмы умножения матриц\footnote{В противовес описанным выше, не являющимся комбинаторными. Стоит отметить, что строгое определение комбинаторных алгоритмов отсутствует, хотя этот термин и получил широкое употребление. В частности, Н.~Бансал (Nikhil Bansal) и Р.~Уильямс (Ryan Williams) в работе~\cite{5438580} дают определение комбинаторного алгоритма, но тут же замечают следующее: ``We would like to give a definition of ``combinatorial algorithm'', but this appears elusive. Although the term has been used in many of the cited references, nothing in the literature resembles a definition. For the purposes of this paper, let us think of a ``combinatorial algorithm'' simply as one that does not call an oracle for ring matrix multiplication.''. Ещё один вариант определения и его обсуждение можно найти в~\cite{das2018lower}.}. Классический результат в данной области --- это алгоритм четырёх русских, предложенный  В. Л. Арлазаровым, Е. А. Диницем, М. А. Кронродом и И. А. Фараджевым в 1970 году~\cite{ArlDinKro70}, позволяющий перемножить матрицы над конечным полукольцом за $O(n^3/\log n)$. Лучшим результатом\footnote{В работе~\cite{das2018lower} предложен алгоритм со сложностью $\Omega(n^{7/3}/2^{O(\sqrt{\log n})})$, однако авторы утверждают, тчо сами не уверены в комбинаторности предложенного решения. По-видимому, полученные результаты ещё должны быть проверены сообществом.} в настоящее время является алгоритм со сложностью $\hat{O}(n^3/\log^4 n)$\footnote{Нотация $\hat{O}$ скрывает $poly(\log\log)$ коэффициенты.}~\cite{10.1007/978-3-662-47672-7_89}.

Как видим, особенности алгебраических структур накладывают серьёзные ограничения на возможности конструирования алгоритмов. Отметим, что, хотя, в указанных случаях и предлагаются решения лучшие, чем наивное кубическое, они обладают принципиально разной асимптотической сложностью. в первом случае сложность оценивается полиномом, степень которого меньше третьей. Такие решения принято называть \textit{истинно субкубическими} (truly subcubic). В то время как в случае комбинаторных алгоритмов степень полинома остается прежней, третьей, хотя сложность и уменьшается на логарифмический фактор. Такие решения принято называть \textit{слегка субкубическими} (mildly subcubic). Естественный вопрос о существовании истинно субкубического алгоритма перемножения матриц над полукольцами (или же комбинаторного перемножения матриц) всё ещё не решён\footnote{Один из кандидатов --- работа~\cite{das2018lower}, однако на текущий момент предложенное в ней решение  требует проверки.}.

%Заметим, что скалярная операция --- это частный случай произвеления Кронекера: достаточно превратить элемент носителя полугруппы в матрицу размера $1\times 1$.

%\section{Вопросы и задачи}
%\begin{enumerate}
%	\item Привидите примеры некоммутативных операций.
%	\item Привидите примеры ситуаций, когда наличие у бинарных операций каких-либо дополнитльных свойств (ассоциативности, коммутативности), позволяет строить более эффективные алгоритмы, чем в общем случае.
%\end{enumerate}